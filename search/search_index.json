{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"<p>This document will serve as an introduction to and usage example for the libplacebo API. This is not intended as a full API reference, for that you should see the repository of header files, which are written to be (hopefully) understandable as-is.</p> <p>libplacebo exposes large parts of its internal abstractions publicly. This guide will take the general approach of starting as high level as possible and diving into the details in later chapters.</p> <p>A full listing of currently available APIs and their corresponding header files can be seen here.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started using libplacebo, you need to install it (and its development headers) somehow onto your system. On most distributions, this should be as simple as installing the corresponding <code>libplacebo-devel</code> package, or the appropriate variants.</p> <p>You can see a fill list of libplacebo packages and their names on repology.</p> <p>API versions</p> <p>This document is targeting the \"v4 API\" overhaul, and as such, examples provided will generally fail to compile on libplacebo versions below v4.x.</p> <p>Alternatively, you can install it from the source code. For that, see the build instructions located here.</p>"},{"location":"basic-rendering/","title":"Basic windowing / output example","text":"<p>We will demonstrate the basics of the libplacebo GPU output API with a worked example. The goal is to show a simple color on screen.</p>"},{"location":"basic-rendering/#creating-a-pl_log","title":"Creating a <code>pl_log</code>","text":"<p>Almost all major entry-points into libplacebo require providing a log callback (or <code>NULL</code> to disable logging). This is abstracted into the <code>pl_log</code> object type, which we can create with <code>pl_log_create</code>:</p> <pre><code>#include &lt;libplacebo/log.h&gt;\n\npl_log pllog;\n\nint main()\n{\n    pllog = pl_log_create(PL_API_VER, pl_log_params(\n        .log_cb = pl_log_color,\n        .log_level = PL_LOG_INFO,\n    ));\n\n    // ...\n\n    pl_log_destroy(&amp;pllog);\n    return 0;\n}\n</code></pre> <p>Compiling</p> <p>You can compile this example with:</p> <pre><code>$ gcc example.c -o example `pkg-config --cflags --libs libplacebo`\n</code></pre> <p>The parameter <code>PL_API_VER</code> has no special significance and is merely included for historical reasons. Aside from that, this snippet introduces a number of core concepts of the libplacebo API:</p>"},{"location":"basic-rendering/#parameter-structs","title":"Parameter structs","text":"<p>For extensibility, almost all libplacebo calls take a pointer to a <code>const struct pl_*_params</code>, into which all extensible parameters go. For convenience, libplacebo provides macros which create anonymous params structs on the stack (and also fill in default parameters). Note that this only works for C99 and above, users of C89 and C++ must initialize parameter structs manually.</p> <p>Under the hood, <code>pl_log_params(...)</code> just translates to <code>&amp;((struct pl_log_params) { /* default params */, ... })</code>. This style of API allows libplacebo to effectively simulate optional named parameters.</p> <p>On default parameters</p> <p>Wherever possible, parameters are designed in such a way that <code>{0}</code> gives you a minimal parameter structure, with default behavior and no optional features enabled. This is done for forwards compatibility - as new features are introduced, old struct initializers will simply opt out of them.</p>"},{"location":"basic-rendering/#destructors","title":"Destructors","text":"<p>All libplacebo objects must be destroyed manually using the corresponding <code>pl_*_destroy</code> call, which takes a pointer to the variable the object is stored in. The resulting variable is written to <code>NULL</code>. This helps prevent use-after-free bugs.</p> <p>NULL</p> <p>As a general rule, all libplacebo destructors are safe to call on variables containing <code>NULL</code>. So, users need not explicitly <code>NULL</code>-test before calling destructors on variables.</p>"},{"location":"basic-rendering/#creating-a-window","title":"Creating a window","text":"<p>While libplacebo can work in isolation, to render images offline, for the sake of this guide we want to provide something graphical on-screen. As such, we need to create some sort of window. Libplacebo provides no built-in mechanism for this, it assumes the API user will already have a windowing system in-place.</p> <p>Complete examples (based on GLFW and SDL) can be found in the libplacebo demos. But for now, we will focus on getting a very simple window on-screen using GLFW:</p> <pre><code>// ...\n\n#include &lt;GLFW/glfw3.h&gt;\n\nconst char * const title = \"libplacebo demo\";\nint width = 800;\nint height = 600;\n\nGLFWwindow *window;\n\nint main()\n{\n    pllog = pl_log_create(PL_API_VER, pl_log_params(\n        .log_level = PL_LOG_INFO,\n    ));\n\n    if (!glfwInit())\n        return 1;\n\n    window = glfwCreateWindow(width, height, title, NULL, NULL);\n    if (!window)\n        return 1;\n\n    while (!glfwWindowShouldClose(window)) {\n        glfwWaitEvents();\n    }\n\n    glfwDestroyWindow(window);\n    glfwTerminate();\n    pl_log_destroy(&amp;pllog);\n    return 0;\n}\n</code></pre> <p>Compiling</p> <p>We now also need to include the glfw3 library to compile this example.</p> <pre><code>$ gcc example.c -o example `pkg-config --cflags --libs glfw3 libplacebo`\n</code></pre>"},{"location":"basic-rendering/#creating-the-pl_gpu","title":"Creating the <code>pl_gpu</code>","text":"<p>All GPU operations are abstracted into an internal <code>pl_gpu</code> object, which serves as the primary entry-point to any sort of GPU interaction. This object cannot be created directly, but must be obtained from some graphical API: currently there are Vulkan, OpenGL or D3D11. A <code>pl_gpu</code> can be accessed from an API-specific object like <code>pl_vulkan</code>, <code>pl_opengl</code> and <code>pl_d3d11</code>.</p> <p>In this guide, for simplicity, we will be using OpenGL, simply because that's what GLFW initializes by default.</p> <pre><code>// ...\n\npl_opengl opengl;\n\nstatic bool make_current(void *priv);\nstatic void release_current(void *priv);\n\nint main()\n{\n    // ...\n    window = glfwCreateWindow(width, height, title, NULL, NULL);\n    if (!window)\n        return 1;\n\n    opengl = pl_opengl_create(pllog, pl_opengl_params(\n        .get_proc_addr      = glfwGetProcAddress,\n        .allow_software     = true,         // allow software rasterers\n        .debug              = true,         // enable error reporting\n        .make_current       = make_current, // (1)\n        .release_current    = release_current,\n    ));\n    if (!opengl)\n        return 2;\n\n    while (!glfwWindowShouldClose(window)) {\n        glfwWaitEvents();\n    }\n\n    pl_opengl_destroy(&amp;opengl);\n    glfwDestroyWindow(window);\n    glfwTerminate();\n    pl_log_destroy(&amp;pllog);\n    return 0;\n}\n\nstatic bool make_current(void *priv)\n{\n    glfwMakeContextCurrent(window);\n    return true;\n}\n\nstatic void release_current(void *priv)\n{\n    glfwMakeContextCurrent(NULL);\n}\n</code></pre> <ol> <li> <p>Setting this allows the resulting <code>pl_gpu</code> to be thread-safe, which     enables asynchronous transfers to be used. The alternative is to simply     call <code>glfwMakeContextCurrent</code> once after creating the window.</p> <p>This method of making the context current is generally preferred, however, so we've demonstrated it here for completeness' sake.</p> </li> </ol>"},{"location":"basic-rendering/#creating-a-swapchain","title":"Creating a swapchain","text":"<p>All access to window-based rendering commands are abstracted into an object known as a \"swapchain\" (from Vulkan terminology), including the default backbuffers on D3D11 and OpenGL. If we want to present something to screen, we need to first create a <code>pl_swapchain</code>.</p> <p>We can use this swapchain to perform the equivalent of <code>gl*SwapBuffers</code>:</p> <pre><code>// ...\npl_swapchain swchain;\n\nstatic void resize_cb(GLFWwindow *win, int new_w, int new_h)\n{\n    width  = new_w;\n    height = new_h;\n    pl_swapchain_resize(swchain, &amp;width, &amp;height);\n}\n\nint main()\n{\n    // ...\n    if (!opengl)\n        return 2;\n\n    swchain = pl_opengl_create_swapchain(opengl, pl_opengl_swapchain_params(\n        .swap_buffers   = (void (*)(void *)) glfwSwapBuffers,\n        .priv           = window,\n    ));\n    if (!swchain)\n        return 2;\n\n    // (2)\n    if (!pl_swapchain_resize(swchain, &amp;width, &amp;height))\n        return 2;\n    glfwSetFramebufferSizeCallback(window, resize_cb);\n\n    while (!glfwWindowShouldClose(window)) {\n        pl_swapchain_swap_buffers(swchain);\n        glfwPollEvents(); // (1)\n    }\n\n    pl_swapchain_destroy(&amp;swchain);\n    pl_opengl_destroy(&amp;opengl);\n    glfwDestroyWindow(window);\n    glfwTerminate();\n    pl_log_destroy(&amp;pllog);\n    return 0;\n}\n</code></pre> <ol> <li> <p>We change this from <code>glfwWaitEvents</code> to <code>glfwPollEvents</code> because     we now want to re-run our main loop once per vsync, rather than only when     new events arrive.  The <code>pl_swapchain_swap_buffers</code> call will ensure     that this does not execute too quickly.</p> </li> <li> <p>The swapchain needs to be resized to fit the size of the window, which in     GLFW is handled by listening to a callback. In addition to setting this     callback, we also need to inform the swapchain of the initial window size.</p> <p>Note that the <code>pl_swapchain_resize</code> function handles both resize requests and size queries - hence, the actual swapchain size is returned back to the passed variables.</p> </li> </ol>"},{"location":"basic-rendering/#getting-pixels-on-the-screen","title":"Getting pixels on the screen","text":"<p>With a swapchain in hand, we're now equipped to start drawing pixels to the screen:</p> <pre><code>// ...\n\nstatic void render_frame(struct pl_swapchain_frame frame)\n{\n    pl_gpu gpu = opengl-&gt;gpu;\n\n    pl_tex_clear(gpu, frame.fbo, (float[4]){ 1.0, 0.5, 0.0, 1.0 });\n}\n\nint main()\n{\n    // ...\n\n    while (!glfwWindowShouldClose(window)) {\n        struct pl_swapchain_frame frame;\n        while (!pl_swapchain_start_frame(swchain, &amp;frame))\n            glfwWaitEvents(); // (1)\n        render_frame(frame);\n        if (!pl_swapchain_submit_frame(swchain))\n            break; // (2)\n\n        pl_swapchain_swap_buffers(swchain);\n        glfwPollEvents();\n    }\n\n    // ...\n}\n</code></pre> <ol> <li> <p>If <code>pl_swapchain_start_frame</code> fails, it typically means the window is     hidden, minimized or blocked. This is not a fatal condition, and as such     we simply want to process window events until we can resume rendering.</p> </li> <li> <p>If <code>pl_swapchain_submit_frame</code> fails, it typically means the window has     been lost, and further rendering commands are not expected to succeed.     As such, in this case, we simply terminate the example program.</p> </li> </ol> <p>Our main render loop has changed into a combination of <code>pl_swapchain_start_frame</code>, rendering, and <code>pl_swapchain_submit_frame</code>. To start with, we simply use the <code>pl_tex_clear</code> function to blit a constant orange color to the framebuffer.</p>"},{"location":"basic-rendering/#interlude-rendering-commands","title":"Interlude: Rendering commands","text":"<p>The previous code snippet represented our first foray into the <code>pl_gpu</code> API. For more detail on this API, see the GPU API section. But as a general rule of thumb, all <code>pl_gpu</code>-level operations are thread safe, asynchronous (except when returning something to the CPU), and internally refcounted (so you can destroy all objects as soon as you no longer need the reference).</p> <p>In the example loop, <code>pl_swapchain_swap_buffers</code> is the only operation that actually flushes commands to the GPU. You can force an early flush with <code>pl_gpu_flush()</code> or <code>pl_gpu_finish()</code>, but other than that, commands will \"queue\" internally and complete asynchronously at some unknown point in time, until forward progress is needed (e.g. <code>pl_tex_download</code>).</p>"},{"location":"basic-rendering/#conclusion","title":"Conclusion","text":"<p>We have demonstrated how to create a window, how to initialize the libplacebo API, create a GPU instance based on OpenGL, and how to write a basic rendering loop that blits a single color to the framebuffer.</p> <p>Here is a complete transcript of the example we built in this section:</p> Basic rendering <pre><code>#include &lt;GLFW/glfw3.h&gt;\n\n#include &lt;libplacebo/log.h&gt;\n#include &lt;libplacebo/opengl.h&gt;\n#include &lt;libplacebo/gpu.h&gt;\n\nconst char * const title = \"libplacebo demo\";\nint width = 800;\nint height = 600;\n\nGLFWwindow *window;\n\npl_log pllog;\npl_opengl opengl;\npl_swapchain swchain;\n\nstatic bool make_current(void *priv);\nstatic void release_current(void *priv);\n\nstatic void resize_cb(GLFWwindow *win, int new_w, int new_h)\n{\n    width  = new_w;\n    height = new_h;\n    pl_swapchain_resize(swchain, &amp;width, &amp;height);\n}\n\nstatic void render_frame(struct pl_swapchain_frame frame)\n{\n    pl_gpu gpu = opengl-&gt;gpu;\n\n    pl_tex_clear(gpu, frame.fbo, (float[4]){ 1.0, 0.5, 0.0, 1.0 });\n}\n\nint main()\n{\n    pllog = pl_log_create(PL_API_VER, pl_log_params(\n        .log_cb = pl_log_color,\n        .log_level = PL_LOG_INFO,\n    ));\n\n    if (!glfwInit())\n        return 1;\n\n    window = glfwCreateWindow(width, height, title, NULL, NULL);\n    if (!window)\n        return 1;\n\n    opengl = pl_opengl_create(pllog, pl_opengl_params(\n        .get_proc_addr      = glfwGetProcAddress,\n        .allow_software     = true,         // allow software rasterers\n        .debug              = true,         // enable error reporting\n        .make_current       = make_current,\n        .release_current    = release_current,\n    ));\n\n    swchain = pl_opengl_create_swapchain(opengl, pl_opengl_swapchain_params(\n        .swap_buffers   = (void (*)(void *)) glfwSwapBuffers,\n        .priv           = window,\n    ));\n    if (!swchain)\n        return 2;\n\n    if (!pl_swapchain_resize(swchain, &amp;width, &amp;height))\n        return 2;\n    glfwSetFramebufferSizeCallback(window, resize_cb);\n\n    while (!glfwWindowShouldClose(window)) {\n        struct pl_swapchain_frame frame;\n        while (!pl_swapchain_start_frame(swchain, &amp;frame))\n            glfwWaitEvents();\n        render_frame(frame);\n        if (!pl_swapchain_submit_frame(swchain))\n            break;\n\n        pl_swapchain_swap_buffers(swchain);\n        glfwPollEvents();\n    }\n\n    pl_swapchain_destroy(&amp;swchain);\n    pl_opengl_destroy(&amp;opengl);\n    glfwDestroyWindow(window);\n    glfwTerminate();\n    pl_log_destroy(&amp;pllog);\n    return 0;\n}\n\nstatic bool make_current(void *priv)\n{\n    glfwMakeContextCurrent(window);\n    return true;\n}\n\nstatic void release_current(void *priv)\n{\n    glfwMakeContextCurrent(NULL);\n}\n</code></pre>"},{"location":"custom-shaders/","title":"Custom Shaders (mpv .hook syntax)","text":"<p>libplacebo supports the same custom shader syntax used by mpv, with some important changes. This document will serve as a complete reference for this syntax.</p>"},{"location":"custom-shaders/#overview","title":"Overview","text":"<p>In general, user shaders are divided into distinct blocks. Each block can define a shader, a texture, a buffer, or a tunable parameter. Each block starts with a collection of header directives, which are lines starting with the syntax <code>//!</code>.</p> <p>As an example, here is a simple shader that simply inverts the video signal:</p> <pre><code>//!HOOK LUMA\n//!HOOK RGB\n//!BIND HOOKED\n\nvec4 hook()\n{\n    vec4 color = HOOKED_texOff(0);\n    color.rgb = vec3(1.0) - color.rgb;\n    return color;\n}\n</code></pre> <p>This shader defines one block - a shader block which hooks into the two texture stages <code>LUMA</code> and <code>RGB</code>, binds the hooked texture, inverts the value of the <code>rgb</code> channels, and then returns the modified color.</p>"},{"location":"custom-shaders/#expressions","title":"Expressions","text":"<p>In a few contexts, shader directives accept arithmetic expressions, denoted by <code>&lt;expr&gt;</code> in the listing below. For historical reasons, all expressions are given in reverse polish notation (RPN), and the only value type is a floating point number. The following value types and arithmetic operations are available:</p> <ul> <li><code>1.234</code>: Literal float constant, evaluates to itself.</li> <li><code>NAME.w</code>, <code>NAME.width</code>: Evaluates to the width of a texture with name <code>NAME</code>.</li> <li><code>NAME.h</code>, <code>NAME.height</code>: Evaluates to the height of a texture with name <code>NAME</code>.</li> <li><code>PAR</code>: Evaluates to the value of a tunable shader parameter with name <code>PAR</code>.</li> <li><code>+</code>: Evaluates to <code>X+Y</code>.</li> <li><code>-</code>: Evaluates to <code>X-Y</code>.</li> <li><code>*</code>: Evaluates to <code>X*Y</code>.</li> <li><code>/</code>: Evaluates to <code>X/Y</code>.</li> <li><code>%</code>: Evaluates to <code>fmod(X, Y)</code>.</li> <li><code>&gt;</code>: Evaluates to <code>(X &gt; Y) ? 1.0 : 0.0</code>.</li> <li><code>&lt;</code>: Evaluates to <code>(X &lt; Y) ? 1.0 : 0.0</code>.</li> <li><code>=</code>: Evaluates to <code>fuzzy_eq(X, Y) ? 1.0 : 0.0</code>, with some tolerance to   allow for floating point inaccuracy. (Around 1 ppm)</li> <li><code>!</code>: Evaluates to <code>X ? 0.0 : 1.0</code>.</li> </ul> <p>Note that <code>+</code> and <code>*</code> can be used as suitable replacements for the otherwise absent boolean logic expressions (<code>||</code> and <code>&amp;&amp;</code>).</p>"},{"location":"custom-shaders/#shaders","title":"Shaders","text":"<p>Shaders are the default block type, and have no special syntax to indicate their presence. Shader stages contain raw GLSL code that will be (conditionally) executed. This GLSL snippet must define a single function <code>vec4 hook()</code>, or <code>void hook()</code> for compute shaders.</p> <p>During the execution of any shader, the following global variables are made available:</p> <ul> <li><code>int frame</code>: A raw counter tracking the number of executions of this shader   stage.</li> <li><code>float random</code>: A pseudo-random float uniformly distributed in the range   <code>[0,1)</code>.</li> <li><code>vec2 input_size</code>: The nominal size (in pixels) of the original input image.</li> <li><code>vec2 target_size</code>: The nominal size (in pixels) of the output rectangle.</li> <li><code>vec2 tex_offset</code>: The nominal offset (in pixels), of the original input crop.</li> <li><code>vec4 linearize(vec4 color)</code>: Linearize the input color according to the   image's tagged gamma function.</li> <li><code>vec4 delinearize(vec4 color)</code>: Opposite counterpart to <code>linearize</code>.</li> </ul> <p>Shader stages accept the following directives:</p>"},{"location":"custom-shaders/#hook-texture","title":"<code>HOOK &lt;texture&gt;</code>","text":"<p>A <code>HOOK</code> directive determines when a shader stage is run. During internal processing, libplacebo goes over a number of pre-defined hook points at set points in the processing pipeline. It is only possible to intercept the image, and run custom shaders, at these fixed hook points.</p> <p>Here is a current list of hook points:</p> <ul> <li><code>RGB</code>: Input plane containing RGB values</li> <li><code>LUMA</code>: Input plane containing a Y value</li> <li><code>CHROMA</code>: Input plane containing chroma values (one or both)</li> <li><code>ALPHA</code>: Input plane containing a single alpha value</li> <li><code>XYZ</code>: Input plane containing XYZ values</li> <li><code>CHROMA_SCALED</code>: Chroma plane, after merging and upscaling to luma size</li> <li><code>ALPHA_SCALED</code>: Alpha plane, after upscaling to luma size</li> <li><code>NATIVE</code>: Merged input planes, before any sort of color conversion (as-is)</li> <li><code>MAIN</code>: After conversion to RGB, before linearization/scaling</li> <li><code>LINEAR</code>: After conversion to linear light (for scaling purposes)</li> <li><code>SIGMOID</code>: After conversion to sigmoidized light (for scaling purposes)</li> <li><code>PREKERNEL</code>: Immediately before the execution of the main scaler kernel</li> <li><code>POSTKERNEL</code>: Immediately after the execution of the main scaler kernel</li> <li><code>SCALED</code>: After scaling, in either linear or non-linear light RGB</li> <li><code>PREOUTPUT</code>: After color conversion to target colorspace, before alpha blending</li> <li><code>OUTPUT</code>: After alpha blending, before dithering and final output pass</li> </ul> <p><code>MAINPRESUB</code></p> <p>In mpv, <code>MAIN</code> and <code>MAINPRESUB</code> are separate shader stages, because the mpv option <code>--blend-subtitles=video</code> allows rendering overlays directly onto the pre-scaled video stage. libplacebo does not support this feature, and as such, the <code>MAINPRESUB</code> shader stage does not exist. It is still valid to refer to this name in shaders, but it is handled identically to <code>MAIN</code>.</p> <p>It's possible for a hook point to never fire. For example, <code>SIGMOID</code> will not fire when downscaling, as sigmoidization only happens when upscaling. Similarly, <code>LUMA</code>/<code>CHROMA</code> will not fire on an RGB video and vice versa.</p> <p>A single shader stage may hook multiple hook points simultaneously, for example, to cover both <code>LUMA</code> and <code>RGB</code> cases with the same logic. (See the example shader in the introduction)</p>"},{"location":"custom-shaders/#bind-texture","title":"<code>BIND &lt;texture&gt;</code>","text":"<p>The <code>BIND</code> directive makes a texture available for use in the shader. This can be any of the previously named hook points, a custom texture define by a <code>TEXTURE</code> block, a custom texture saved by a <code>SAVE</code> directive, or the special value <code>HOOKED</code> which allows binding whatever texture hook dispatched this shader stage.</p> <p>A bound texture will define the following GLSL functions (as macros):</p> <ul> <li><code>sampler2D NAME_raw</code>: A reference to the raw texture sampler itself.</li> <li><code>vec2 NAME_pos</code>: The texel coordinates of the current pixel.</li> <li><code>vec2 NAME_map(ivec2 id)</code>: A function that maps from <code>gl_GlobalInvocationID</code>   to texel coordinates. (Compute shaders)</li> <li><code>vec2 NAME_size</code>: The size (in pixels) of the texture.</li> <li><code>vec2 NAME_pt</code>: Convenience macro for <code>1.0 / NAME_size</code>. The size of a   single pixel (in texel coordinates).</li> <li><code>vec2 NAME_off</code>: The sample offset of the texture. Basically, the pixel   coordinates of the top-left corner of the sampled area.</li> <li><code>float NAME_mul</code>: The coefficient that must be multiplied into sampled   values in order to rescale them to <code>[0,1]</code>.</li> <li><code>vec4 NAME_tex(vec2 pos)</code>: A wrapper around <code>NAME_mul * textureLod(NAME_raw,   pos, 0.0)</code>.</li> <li><code>vec4 NAME_texOff(vec2 offset)</code>: A wrapper around <code>NAME_tex(NAME_pos + NAME_pt * offset)</code>.   This can be used to easily access adjacent pixels, e.g. <code>NAME_texOff(-1,2)</code>   samples a pixel one to the left and two to the bottom of the current   location.</li> <li><code>vec4 NAME_gather(vec2 pos, int c)</code>: A wrapper around   <code>NAME_mul * textureGather(pos, c)</code>, with appropriate scaling. (Only when   supported<sup>3</sup>)</li> </ul> <p>Rotation matrix</p> <p>For compatibility with mpv, we also define a <code>mat2 NAME_rot</code> which is simply equal to a 2x2 identity matrix. libplacebo never rotates input planes - all rotation happens during the final output to the display.</p> <p>This same directive can also be used to bind buffer blocks (i.e. uniform/storage buffers), as defined by the <code>BUFFER</code> directive.</p>"},{"location":"custom-shaders/#save-texture","title":"<code>SAVE &lt;texture&gt;</code>","text":"<p>By default, after execution of a shader stage, the resulting output is captured back into the same hooked texture that triggered the shader. This behavior can be overridden using the explicit <code>SAVE</code> directive. For example, a shader might need access to a low-res version of the luma input texture in order to process chroma:</p> <pre><code>//!HOOK CHROMA\n//!BIND CHROMA\n//!BIND LUMA\n//!SAVE LUMA_LOWRES\n//!WIDTH CHROMA.w\n//!HEIGHT CHROMA.h\n\nvec4 hook()\n{\n    return LUMA_texOff(0);\n}\n</code></pre> <p>This shader binds both luma and chroma and resizes the luma plane down to the size of the chroma plane, saving the result as a new texture <code>LUMA_LOWRES</code>. In general, you can pick any name you want, here.</p>"},{"location":"custom-shaders/#desc-description","title":"<code>DESC &lt;description&gt;</code>","text":"<p>This purely informative directive simply gives the shader stage a name. This is the name that will be reported to the shader stage and execution time metrics.</p>"},{"location":"custom-shaders/#offset-xo-yo-align","title":"<code>OFFSET &lt;xo yo | ALIGN&gt;</code>","text":"<p>This directive indicates a pixel shift (offset) introduced by this pass. These pixel offsets will be accumulated and corrected automatically as part of plane alignment / main scaling.</p> <p>A special value of <code>ALIGN</code> will attempt to counteract any existing offset of the hooked texture by aligning it with reference plane (i.e. luma). This can be used to e.g. introduce custom chroma scaling in a way that doesn't break chroma subtexel offsets.</p> <p>An example:</p> <pre><code>//!HOOK LUMA\n//!BIND HOOKED\n//!OFFSET 100.5 100.5\n\nvec4 hook()\n{\n    // Constant offset by N pixels towards the bottom right\n    return HOOKED_texOff(-vec2(100.5));\n}\n</code></pre> <p>This (slightly silly) shader simply shifts the entire sampled region to the bottom right by 100.5 pixels, and propagates this shift to the main scaler using the <code>OFFSET</code> directive. As such, the end result of this is that there is no visible shift of the overall image, but some detail (~100 pixels) near the bottom-right border is lost due to falling outside the bounds of the texture.</p>"},{"location":"custom-shaders/#width-expr-height-expr","title":"<code>WIDTH &lt;expr&gt;</code>, <code>HEIGHT &lt;expr&gt;</code>","text":"<p>These directives can be used to override the dimensions of the resulting texture. Note that not all textures can be resized this way. Currently, only <code>RGB</code>, <code>LUMA</code>, <code>CHROMA</code>, <code>XYZ</code>, <code>NATIVE</code> and <code>MAIN</code> are resizable. Trying to save a texture with an incompatible size to any other shader stage will result in an error.</p>"},{"location":"custom-shaders/#when-expr","title":"<code>WHEN &lt;expr&gt;</code>","text":"<p>This directive takes an expression that can be used to make shader stages conditionally executed. If this evaluates to 0, the shader stage will be skipped.</p> <p>Example:</p> <pre><code>//!PARAM strength\n//!TYPE float\n//!MINIMUM 0\n1.0\n\n//!HOOK MAIN\n//!BIND HOOKED\n//!WHEN intensity 0 &gt;\n//!DESC do something based on 'intensity'\n...\n</code></pre> <p>This example defines a shader stage that only conditionally executes itself if the value of the <code>intensity</code> shader parameter is non-zero.</p>"},{"location":"custom-shaders/#components-num","title":"<code>COMPONENTS &lt;num&gt;</code>","text":"<p>This directive overrides the number of components present in a texture. For example, if you want to extract a one-dimensional feature map from the otherwise 3 or 4 dimensional <code>MAIN</code> texture, you can use this directive to save on memory bandwidth and consumption by having libplacebo only allocate a one-component texture to store the feature map in:</p> <pre><code>//!HOOK MAIN\n//!BIND HOOKED\n//!SAVE featuremap\n//!COMPONENTS 1\n</code></pre>"},{"location":"custom-shaders/#compute-bw-bh-tw-th","title":"<code>COMPUTE &lt;bw&gt; &lt;bh&gt; [&lt;tw&gt; &lt;th&gt;]</code>","text":"<p>This directive specifies that the shader should be treated as a compute shader, with the block size <code>bw</code> and <code>bh</code>. The compute shader will be dispatched with however many blocks are necessary to completely tile over the output. Within each block, there will be <code>tw*th</code> threads, forming a single work group. In other words: <code>tw</code> and <code>th</code> specify the work group size, which can be different from the block size. So for example, a compute shader with <code>bw = bh = 32</code> and <code>tw = th = 8</code> running on a <code>500x500</code> texture would dispatch <code>16x16</code> blocks (rounded up), each with <code>8x8</code> threads.</p> <p>Instead of defining a <code>vec4 hook()</code>, compute shaders must define a <code>void hook()</code> which results directly to the output texture, a <code>writeonly image2D out_image</code> made available to the shader stage.</p> <p>For example, here is a shader executing a single-pass 41x41 convolution (average blur) on the luma plane, using a compute shader to share sampling work between adjacent threads in a work group:</p> <pre><code>//!HOOK LUMA\n//!BIND HOOKED\n//!COMPUTE 32 32\n//!DESC avg convolution\n\n// Kernel size, 41x41 as an example\nconst ivec2 ksize = ivec2(41, 41);\nconst ivec2 offset = ksize / 2;\n\n// We need to load extra source texels to account for padding due to kernel\n// overhang\nconst ivec2 isize = ivec2(gl_WorkGroupSize) + ksize - 1;\n\nshared float inp[isize.y][isize.x];\n\nvoid hook()\n{\n    // load texels into shmem\n    ivec2 base = ivec2(gl_WorkGroupID) * ivec2(gl_WorkGroupSize);\n    for (uint y = gl_LocalInvocationID.y; y &lt; isize.y; y += gl_WorkGroupSize.y) {\n        for (uint x = gl_LocalInvocationID.x; x &lt; isize.x; x += gl_WorkGroupSize.x)\n            inp[y][x] = texelFetch(HOOKED_raw, base + ivec2(x,y) - offset, 0).x;\n    }\n\n    // synchronize threads\n    barrier();\n\n    // do convolution\n    float sum;\n    for (uint y = 0; y &lt; ksize.y; y++) {\n        for (uint x = 0; x &lt; ksize.x; x++)\n            sum += inp[gl_LocalInvocationID.y+y][gl_LocalInvocationID.x+x];\n    }\n\n    vec4 color = vec4(HOOKED_mul * sum / (ksize.x * ksize.y), 0, 0, 1);\n    imageStore(out_image, ivec2(gl_GlobalInvocationID), color);\n}\n</code></pre>"},{"location":"custom-shaders/#textures","title":"Textures","text":"<p>Custom textures can be defined and made available to shader stages using <code>TEXTURE</code> blocks. These can be used to provide e.g. LUTs or pre-trained weights.</p> <p>The data for a texture is provided as a raw hexadecimal string encoding the in-memory representation of a texture, according to its given texture format, for example:</p> <pre><code>//!TEXTURE COLORS\n//!SIZE 3 3\n//!FORMAT rgba32f\n//!FILTER NEAREST\n//!BORDER REPEAT\n0000803f000000000000000000000000000000000000803f00000000000000000000000\n0000000000000803f00000000000000000000803f0000803f000000000000803f000000\n000000803f000000000000803f0000803f00000000000000009a99993e9a99993e9a999\n93e000000009a99193F9A99193f9a99193f000000000000803f0000803f0000803f0000\n0000\n</code></pre> <p>Texture blocks accept the following directives:</p>"},{"location":"custom-shaders/#texture-name","title":"<code>TEXTURE &lt;name&gt;</code>","text":"<p>This must be the first directive in a texture block, and marks it as such. The name given is the name that the texture will be referred to (via <code>BIND</code> directives).</p>"},{"location":"custom-shaders/#size-width-height-depth","title":"<code>SIZE &lt;width&gt; [&lt;height&gt; [&lt;depth&gt;]]</code>","text":"<p>This directive gives the size of the texture, as integers. For example, <code>//!SIZE 512 512</code> marks a 512x512 texture block. Textures can be 1D, 2D or 3D depending on the number of coordinates specified.</p>"},{"location":"custom-shaders/#format-fmt","title":"<code>FORMAT &lt;fmt&gt;</code>","text":"<p>This directive specifies the texture format. A complete list of known textures is exposed as part of the <code>pl_gpu</code> struct metadata, but they follow the format convention <code>rgba8</code>, <code>rg16hf</code>, <code>rgba32f</code>, <code>r64i</code> and so on.</p>"},{"location":"custom-shaders/#filter-linear-nearest","title":"<code>FILTER &lt;LINEAR | NEAREST&gt;</code>","text":"<p>This directive specifies the texture magnification/minification filter.</p>"},{"location":"custom-shaders/#border-clamp-repeat-mirror","title":"<code>BORDER &lt;CLAMP | REPEAT | MIRROR&gt;</code>","text":"<p>This directive specifies the border clamping method of the texture.</p>"},{"location":"custom-shaders/#storage","title":"<code>STORAGE</code>","text":"<p>If present, this directive marks the texture as a storage image. It will still be initialized with the initial values, but rather than being bound as a read-only and immutable <code>sampler2D</code>, it is bound as a <code>readwrite coherent image2D</code>. Such texture scan be used to, for example, store persistent state across invocations of the shader.</p>"},{"location":"custom-shaders/#buffers","title":"Buffers","text":"<p>Custom uniform / storage shader buffer  blocks can be defined using <code>BUFFER</code> directives.</p> <p>The (initial) data for a buffer is provided as a raw hexadecimal string encoding the in-memory representation of a buffer in the corresponding GLSL packing layout (std140 or std430 for uniform and storage blocks, respectively):</p> <pre><code>//!BUFFER buf_uniform\n//!VAR float foo\n//!VAR float bar\n0000000000000000\n\n//!BUFFER buf_storage\n//!VAR vec2 bat\n//!VAR int big[32];\n//!STORAGE\n</code></pre> <p>Buffer blocks accept the following directives:</p>"},{"location":"custom-shaders/#buffer-name","title":"<code>BUFFER &lt;name&gt;</code>","text":"<p>This must be the first directive in a buffer block, and marks it as such. The name given is mostly cosmetic, as individual variables can be accessed directly using the names given in the corresponding <code>VAR</code> directives.</p>"},{"location":"custom-shaders/#storage_1","title":"<code>STORAGE</code>","text":"<p>If present, this directive marks the buffer as a (readwrite coherent) shader storage block, instead of a readonly uniform buffer block. Such storage blocks can be used to track and evolve state across invocations of this shader.</p> <p>Storage blocks may also be initialized with default data, but this is optional. They can also be initialized as part of the first shader execution (e.g. by testing for <code>frame == 0</code>).</p>"},{"location":"custom-shaders/#var-type-name","title":"<code>VAR &lt;type&gt; &lt;name&gt;</code>","text":"<p>This directive appends a new variable to the shader block, with GLSL type <code>&lt;type&gt;</code> and shader name <code>&lt;name&gt;</code>. For example, <code>VAR float foo</code> introduces a <code>float foo;</code> member into the buffer block, and <code>VAR mat4 transform</code> introduces a <code>mat4 transform;</code> member.</p> <p>It is also possible to introduce array variables, using <code>[N]</code> as part of the variable name.</p>"},{"location":"custom-shaders/#tunable-parameters","title":"Tunable parameters","text":"<p>Finally, the <code>PARAM</code> directive allows introducing tunable shader parameters, which are exposed programmatically as part of the C API (<code>pl_hook</code>).<sup>1</sup></p> <p>The default value of a parameter is given as the block body, for example:</p> <pre><code>//!PARAM contrast\n//!DESC Gain to apply to image brightness\n//!TYPE float\n//!MINIMUM 0.0\n//!MAXIMUM 100.0\n1.0\n</code></pre> <p>Parameters accept the following directives:</p>"},{"location":"custom-shaders/#param-name","title":"<code>PARAM &lt;name&gt;</code>","text":"<p>This must be the first directive in a parameter block, and marks it as such. The name given is the name that will be used to refer to this parameter in GLSL code.</p>"},{"location":"custom-shaders/#desc-description_1","title":"<code>DESC &lt;description&gt;</code>","text":"<p>This directive can be used to provide a friendlier description of the shader parameter, exposed as part of the C API to end users.</p>"},{"location":"custom-shaders/#minimum-value-maximum-value","title":"<code>MINIMUM &lt;value&gt;</code>, <code>MAXIMUM &lt;value&gt;</code>","text":"<p>Provides the minimum/maximum value bound of this parameter. If absent, no minimum/maximum is enforced.</p>"},{"location":"custom-shaders/#type-enum-define-dynamic-constant-type","title":"<code>TYPE [ENUM] &lt;DEFINE | [DYNAMIC | CONSTANT] &lt;type&gt;&gt;</code>","text":"<p>This gives the type of the parameter, which determines what type of values it can hold and how it will be made available to the shader. <code>&lt;type&gt;</code> must be a scalar GLSL numeric type, such as <code>int</code>, <code>float</code> or <code>uint</code>.</p> <p>If a type is <code>ENUM</code>, it is treated as an enumeration type. To use this, <code>type</code> must either be <code>int</code> or <code>DEFINE</code>. Instead of providing a single default value, the param body should be a list of all possible enumeration values (as separate lines). These names will be made available inside the shader body (as a <code>#define</code>), as well as inside RPN expressions (e.g. <code>WHEN</code>). The qualifiers <code>MINIMUM</code> and <code>MAXIMUM</code> are ignored for <code>ENUM</code> parameters, with the value range instead being set implicitly from the list of options.</p> <p>The optional qualifiers <code>DYNAMIC</code> or <code>CONSTANT</code> mark the parameter as dynamically changing and compile-time constant, respectively. A <code>DYNAMIC</code> variable is assumed to change frequently, and will be grouped with other frequently-changing input parameters. A <code>CONSTANT</code> parameter will be introduced as a compile-time constant into the shader header, which means thy can be used in e.g. constant expressions such as array sizes.<sup>2</sup></p> <p>Finally, the special type <code>TYPE DEFINE</code> marks a variable as a preprocessor define, which can be used inside <code>#if</code> preprocessor expressions. For example:</p> <pre><code>//!PARAM taps\n//!DESC Smoothing taps\n//!TYPE DEFINE\n//!MINIMUM 0\n//!MAXIMUM 5\n2\n\n//!HOOK LUMA\n//!BIND HOOKED\nconst uint row_size = 2 * taps + 1;\nconst float weights[row_size] = {\n#if taps == 0\n    1.0,\n#endif\n\n#if taps == 1\n    0.10650697891920,\n    0.78698604216159,\n    0.10650697891920,\n#endif\n\n#if taps == 2\n    0.05448868454964,\n    0.24420134200323,\n    0.40261994689424,\n    0.24420134200323,\n    0.05448868454964,\n#endif\n\n    // ...\n};\n</code></pre> <p>An example of an enum parameter:</p> <pre><code>//!PARAM csp\n//!DESC Colorspace\n//!TYPE ENUM int\nBT709\nBT2020\nDCIP3\n\n//!HOOK MAIN\n//!BIND HOOKED\nconst mat3 matrices[3] = {\n    mat3(...), // BT709\n    mat3(...), // BT2020\n    mat3(...), // DCIP3\n};\n\n#define MAT matrices[csp]\n// ...\n</code></pre>"},{"location":"custom-shaders/#full-example","title":"Full example","text":"<p>A collection of full examples can be found in the mpv user shaders wiki, but here is an example of a parametrized Gaussian smoothed film grain compute shader:</p> <pre><code>//!PARAM intensity\n//!DESC Film grain intensity\n//!TYPE float\n//!MINIMUM 0\n0.1\n\n//!PARAM taps\n//!DESC Film grain smoothing taps\n//!TYPE DEFINE\n//!MINIMUM 0\n//!MAXIMUM 5\n2\n\n//!HOOK LUMA\n//!BIND HOOKED\n//!DESC Apply gaussian smoothed film grain\n//!WHEN intensity 0 &gt;\n//!COMPUTE 32 32\n\nconst uint row_size = 2 * taps + 1;\nconst float weights[row_size] = {\n#if taps == 0\n    1.0,\n#endif\n\n#if taps == 1\n    0.10650697891920,\n    0.78698604216159,\n    0.10650697891920,\n#endif\n\n#if taps == 2\n    0.05448868454964,\n    0.24420134200323,\n    0.40261994689424,\n    0.24420134200323,\n    0.05448868454964,\n#endif\n\n#if taps == 3\n    0.03663284536919,\n    0.11128075847888,\n    0.21674532140370,\n    0.27068214949642,\n    0.21674532140370,\n    0.11128075847888,\n    0.03663284536919,\n#endif\n\n#if taps == 4\n    0.02763055063889,\n    0.06628224528636,\n    0.12383153680577,\n    0.18017382291138,\n    0.20416368871516,\n    0.18017382291138,\n    0.12383153680577,\n    0.06628224528636,\n    0.02763055063889,\n#endif\n\n#if taps == 5\n    0.02219054849244,\n    0.04558899978527,\n    0.07981140824009,\n    0.11906462996609,\n    0.15136080967773,\n    0.16396720767670,\n    0.15136080967773,\n    0.11906462996609,\n    0.07981140824009,\n    0.04558899978527,\n    0.02219054849244,\n#endif\n};\n\nconst uvec2 isize = uvec2(gl_WorkGroupSize) + uvec2(2 * taps);\nshared float grain[isize.y][isize.x];\n\n// PRNG\nfloat permute(float x)\n{\n    x = (34.0 * x + 1.0) * x;\n    return fract(x * 1.0/289.0) * 289.0;\n}\n\nfloat seed(uvec2 pos)\n{\n    const float phi = 1.61803398874989;\n    vec3 m = vec3(fract(phi * vec2(pos)), random) + vec3(1.0);\n    return permute(permute(m.x) + m.y) + m.z;\n}\n\nfloat rand(inout float state)\n{\n    state = permute(state);\n    return fract(state * 1.0/41.0);\n}\n\n// Turns uniform white noise into gaussian white noise by passing it\n// through an approximation of the gaussian quantile function\nfloat rand_gaussian(inout float state) {\n    const float a0 = 0.151015505647689;\n    const float a1 = -0.5303572634357367;\n    const float a2 = 1.365020122861334;\n    const float b0 = 0.132089632343748;\n    const float b1 = -0.7607324991323768;\n\n    float p = 0.95 * rand(state) + 0.025;\n    float q = p - 0.5;\n    float r = q * q;\n\n    float g = q * (a2 + (a1 * r + a0) / (r*r + b1*r + b0));\n    g *= 0.255121822830526; // normalize to [-1,1)\n    return g;\n}\n\nvoid hook()\n{\n    // generate grain in `grain`\n    uint num_threads = gl_WorkGroupSize.x * gl_WorkGroupSize.y;\n    for (uint i = gl_LocalInvocationIndex; i &lt; isize.y * isize.x; i += num_threads) {\n        uvec2 pos = uvec2(i % isize.y, i / isize.y);\n        float state = seed(gl_WorkGroupID.xy * gl_WorkGroupSize.xy + pos);\n        grain[pos.y][pos.x] = rand_gaussian(state);\n    }\n\n    // make writes visible\n    barrier();\n\n    // convolve horizontally\n    for (uint y = gl_LocalInvocationID.y; y &lt; isize.y; y += gl_WorkGroupSize.y) {\n        float hsum = 0;\n        for (uint x = 0; x &lt; row_size; x++) {\n            float g = grain[y][gl_LocalInvocationID.x + x];\n            hsum += weights[x] * g;\n        }\n\n        // update grain LUT\n        grain[y][gl_LocalInvocationID.x + taps] = hsum;\n    }\n\n    barrier();\n\n    // convolve vertically\n    float vsum = 0.0;\n    for (uint y = 0; y &lt; row_size; y++) {\n        float g = grain[gl_LocalInvocationID.y + y][gl_LocalInvocationID.x + taps];\n        vsum += weights[y] * g;\n    }\n\n    vec4 color = HOOKED_tex(HOOKED_pos);\n    color.rgb += vec3(intensity * vsum);\n    imageStore(out_image, ivec2(gl_GlobalInvocationID), color);\n}\n</code></pre> <ol> <li> <p>In mpv using <code>--vo=gpu-next</code>, these can be set using the   <code>--glsl-shader-opts</code> option.\u00a0\u21a9</p> </li> <li> <p>On supported platforms, these are implemented using specialization   constants, which can be updated at run-time without requiring a full shader   recompilation.\u00a0\u21a9</p> </li> <li> <p>Because these are macros, their presence can be tested for using   <code>#ifdef</code> inside the GLSL preprocessor.\u00a0\u21a9</p> </li> </ol>"},{"location":"glsl/","title":"GLSL shader system","text":""},{"location":"glsl/#overall-design","title":"Overall design","text":"<p>Shaders in libplacebo are all written in GLSL, and built up incrementally, on demand. Generally, all shaders for each frame are generated per frame. So functions like <code>pl_shader_color_map</code> etc. are run anew for every frame. This makes the renderer very stateless and allows us to directly embed relevant constants, uniforms etc. as part of the same code that generates the actual GLSL shader.</p> <p>To avoid this from becoming wasteful, libplacebo uses an internal string building abstraction (<code>pl_str_builder</code>). Rather than building up a string directly, a <code>pl_str_builder</code> is like a list of string building functions/callbacks to execute in order to generate the actual shader. Combined with an efficient <code>pl_str_builder_hash</code>, this allows us to avoid the bulk of the string templating work for already-cached shaders.</p>"},{"location":"glsl/#legacy-api","title":"Legacy API","text":"<p>For the vast majority of libplacebo's history, the main entry-point into the shader building mechanism was the <code>GLSL()</code> macro (and variants), which works like a <code>printf</code>-append:</p> <pre><code>void pl_shader_extract_features(pl_shader sh, struct pl_color_space csp)\n{\n    if (!sh_require(sh, PL_SHADER_SIG_COLOR, 0, 0))\n        return;\n\n    sh_describe(sh, \"feature extraction\");\n    pl_shader_linearize(sh, &amp;csp);\n    GLSL(\"// pl_shader_extract_features             \\n\"\n         \"{                                         \\n\"\n         \"vec3 lms = %f * \"$\" * color.rgb;          \\n\"\n         \"lms = pow(max(lms, 0.0), vec3(%f));       \\n\"\n         \"lms = (vec3(%f) + %f * lms)               \\n\"\n         \"        / (vec3(1.0) + %f * lms);         \\n\"\n         \"lms = pow(lms, vec3(%f));                 \\n\"\n         \"float I = dot(vec3(%f, %f, %f), lms);     \\n\"\n         \"color = vec4(I, 0.0, 0.0, 1.0);           \\n\"\n         \"}                                         \\n\",\n         PL_COLOR_SDR_WHITE / 10000,\n         SH_MAT3(pl_ipt_rgb2lms(pl_raw_primaries_get(csp.primaries))),\n         PQ_M1, PQ_C1, PQ_C2, PQ_C3, PQ_M2,\n         pl_ipt_lms2ipt.m[0][0], pl_ipt_lms2ipt.m[0][1], pl_ipt_lms2ipt.m[0][2]);\n}\n</code></pre> <p>The special macro <code>$</code> is a stand-in for an identifier (<code>ident_t</code>), which is the internal type used to pass references to loaded uniforms, descriptors and so on:</p> <pre><code>typedef unsigned short ident_t;\n#define $           \"_%hx\"\n#define NULL_IDENT  0u\n\n// ...\n\nident_t sh_var_mat3(pl_shader sh, const char *name, pl_matrix3x3 val);\n#define SH_MAT3(val) sh_var_mat3(sh, \"mat\", val)\n</code></pre> <p>In general, constants in libplacebo are divided into three categories:</p>"},{"location":"glsl/#literal-shader-constants","title":"Literal shader constants","text":"<p>These are values that are expected to change very infrequently (or never), or for which we want to generate a different shader variant per value. Such values should be directly formatted as numbers into the shader text: <code>%d</code>, <code>%f</code> and so on. This is commonly used for array sizes, constants that depend only on hardware limits, constants that never change (but which have a friendly name, like <code>PQ_C2</code> above), and so on.</p> <p>As an example, the debanding iterations weights are hard-coded like this, because the debanding shader is expected to change as a result of a different number of iterations anyway:</p> <pre><code>// For each iteration, compute the average at a given distance and\n// pick it instead of the color if the difference is below the threshold.\nfor (int i = 1; i &lt;= params-&gt;iterations; i++) {\n    GLSL(// Compute a random angle and distance\n         \"d = \"$\".xy * vec2(%d.0 * \"$\", %f);    \\n\" // (1)\n         \"d = d.x * vec2(cos(d.y), sin(d.y));   \\n\"\n         // Sample at quarter-turn intervals around the source pixel\n         \"avg = T(0.0);                         \\n\"\n         \"avg += GET(+d.x, +d.y);               \\n\"\n         \"avg += GET(-d.x, +d.y);               \\n\"\n         \"avg += GET(-d.x, -d.y);               \\n\"\n         \"avg += GET(+d.x, -d.y);               \\n\"\n         \"avg *= 0.25;                          \\n\"\n         // Compare the (normalized) average against the pixel\n         \"diff = abs(res - avg);                \\n\"\n         \"bound = T(\"$\" / %d.0);                \\n\",\n         prng, i, radius, M_PI * 2,\n         threshold, i);\n\n    if (num_comps &gt; 1) {\n        GLSL(\"res = mix(avg, res, greaterThan(diff, bound)); \\n\");\n    } else {\n        GLSL(\"res = mix(avg, res, diff &gt; bound); \\n\");\n    }\n}\n</code></pre> <ol> <li>The <code>%d.0</code> here corresponds to the iteration index <code>i</code>, while the <code>%f</code>     corresponds to the fixed constant <code>M_PI * 2</code>.</li> </ol>"},{"location":"glsl/#specializable-shader-constants","title":"Specializable shader constants","text":"<p>These are used for tunable parameters that are expected to change infrequently during normal playback. These constitute by far the biggest category, and most parameters coming from the various <code>_params</code> structs should be loaded like this.</p> <p>They are loaded using the <code>sh_const_*()</code> functions, which generate a specialization constant on supported platforms, falling back to a literal shader <code>#define</code> otherwise. For anoymous parameters, you can use the short-hands <code>SH_FLOAT</code>, <code>SH_INT</code> etc.:</p> <pre><code>ident_t sh_const_int(pl_shader sh, const char *name, int val);\nident_t sh_const_uint(pl_shader sh, const char *name, unsigned int val);\nident_t sh_const_float(pl_shader sh, const char *name, float val);\n#define SH_INT(val)     sh_const_int(sh, \"const\", val)\n#define SH_UINT(val)    sh_const_uint(sh, \"const\", val)\n#define SH_FLOAT(val)   sh_const_float(sh, \"const\", val)\n</code></pre> <p>Here is an example of them in action:</p> <pre><code>void pl_shader_sigmoidize(pl_shader sh, const struct pl_sigmoid_params *params)\n{\n    if (!sh_require(sh, PL_SHADER_SIG_COLOR, 0, 0))\n        return;\n\n    params = PL_DEF(params, &amp;pl_sigmoid_default_params);\n    float center = PL_DEF(params-&gt;center, 0.75);\n    float slope  = PL_DEF(params-&gt;slope, 6.5);\n\n    // This function needs to go through (0,0) and (1,1), so we compute the\n    // values at 1 and 0, and then scale/shift them, respectively.\n    float offset = 1.0 / (1 + expf(slope * center));\n    float scale  = 1.0 / (1 + expf(slope * (center - 1))) - offset;\n\n    GLSL(\"// pl_shader_sigmoidize                               \\n\"\n         \"color = clamp(color, 0.0, 1.0);                       \\n\"\n         \"color = vec4(\"$\") - vec4(\"$\") *                       \\n\"\n         \"    log(vec4(1.0) / (color * vec4(\"$\") + vec4(\"$\"))   \\n\"\n         \"        - vec4(1.0));                                 \\n\",\n         SH_FLOAT(center), SH_FLOAT(1.0 / slope),\n         SH_FLOAT(scale), SH_FLOAT(offset));\n}\n</code></pre> <p>The advantage of this type of shader constant is that they will be transparently replaced by dynamic uniforms whenever <code>pl_render_params.dynamic_constants</code> is true, which allows the renderer to respond more instantly to changes in the parameters (e.g. as a result of a user dragging a slider around). During \"normal\" playback, they will then be \"promoted\" to actual shader constants to prevent them from taking up registers.</p>"},{"location":"glsl/#dynamic-variables","title":"Dynamic variables","text":"<p>For anything else, e.g. variables which are expected to change very frequently, you can use the generic <code>sh_var()</code> mechanism, which sends constants either as elements of a uniform buffer, or directly as push constants:</p> <pre><code>ident_t sh_var_int(pl_shader sh, const char *name, int val, bool dynamic);\nident_t sh_var_uint(pl_shader sh, const char *name, unsigned int val, bool dynamic);\nident_t sh_var_float(pl_shader sh, const char *name, float val, bool dynamic);\n#define SH_INT_DYN(val)   sh_var_int(sh, \"const\", val, true)\n#define SH_UINT_DYN(val)  sh_var_uint(sh, \"const\", val, true)\n#define SH_FLOAT_DYN(val) sh_var_float(sh, \"const\", val, true)\n</code></pre> <p>These are used primarily when a variable is expected to change very frequently, e.g. as a result of randomness, or for constants which depend on dynamically computed, source-dependent variables (e.g. input frame characteristics):</p> <pre><code>if (params-&gt;show_clipping) {\n    const float eps = 1e-6f;\n    GLSL(\"bool clip_hi, clip_lo;                            \\n\"\n         \"clip_hi = any(greaterThan(color.rgb, vec3(\"$\"))); \\n\"\n         \"clip_lo = any(lessThan(color.rgb, vec3(\"$\")));    \\n\"\n         \"clip_hi = clip_hi || ipt.x &gt; \"$\";                 \\n\"\n         \"clip_lo = clip_lo || ipt.x &lt; \"$\";                 \\n\",\n         SH_FLOAT_DYN(pl_hdr_rescale(PL_HDR_PQ, PL_HDR_NORM, tone.input_max) + eps),\n         SH_FLOAT(pl_hdr_rescale(PL_HDR_PQ, PL_HDR_NORM, tone.input_min) - eps),\n         SH_FLOAT_DYN(tone.input_max + eps),\n         SH_FLOAT(tone.input_min - eps));\n}\n</code></pre>"},{"location":"glsl/#shader-sections-glsl-glslh-glslf","title":"Shader sections (GLSL, GLSLH, GLSLF)","text":"<p>Shader macros come in three main flavors, depending on where the resulting text should be formatted:</p> <ul> <li><code>GLSL</code>: Expanded in the scope of the current <code>main</code> function,   and is related to code directly processing the current pixel value.</li> <li><code>GLSLH</code>: Printed to the 'header', before the first function, but after   variables, uniforms etc. This is used for global definitions, helper   functions, shared memory variables, and so on.</li> <li><code>GLSLF</code>: Printed to the <code>footer</code>, which is always at the end of the current   <code>main</code> function, but before returning to the caller / writing to the   framebuffer. Used to e.g. update SSBO state in preparation for the next   frame.</li> </ul> <p>Finally, there is a fourth category <code>GLSLP</code> (prelude), which is currently only used internally to generate preambles during e.g. compute shader translation.</p>"},{"location":"glsl/#new-pragma-glsl-macro","title":"New #pragma GLSL macro","text":"<p>Starting with libplacebo v6, the internal shader system has been augmented by a custom macro preprocessor, which is designed to ease the boilerplate of writing shaders (and also strip redundant whitespace from generated shaders). The code for this is found in the tools/glsl_preproc directory.</p> <p>In a nutshell, this allows us to embed GLSL snippets directly as <code>#pragma GLSL</code> macros (resp. <code>#pragma GLSLH</code>, <code>#pragma GLSLF</code>):</p> <pre><code>bool pl_shader_sample_bicubic(pl_shader sh, const struct pl_sample_src *src)\n{\n    ident_t tex, pos, pt;\n    float rx, ry, scale;\n    if (!setup_src(sh, src, &amp;tex, &amp;pos, &amp;pt, &amp;rx, &amp;ry, NULL, &amp;scale, true, LINEAR))\n        return false;\n\n    if (rx &lt; 1 || ry &lt; 1) {\n        PL_TRACE(sh, \"Using fast bicubic sampling when downscaling. This \"\n                 \"will most likely result in nasty aliasing!\");\n    }\n\n    // Explanation of how bicubic scaling with only 4 texel fetches is done:\n    //   http://www.mate.tue.nl/mate/pdfs/10318.pdf\n    //   'Efficient GPU-Based Texture Interpolation using Uniform B-Splines'\n\n    sh_describe(sh, \"bicubic\");\n#pragma GLSL /* pl_shader_sample_bicubic */         \\\n    vec4 color;                                     \\\n    {                                               \\\n    vec2 pos = $pos;                                \\\n    vec2 size = vec2(textureSize($tex, 0));         \\\n    vec2 frac  = fract(pos * size + vec2(0.5));     \\\n    vec2 frac2 = frac * frac;                       \\\n    vec2 inv   = vec2(1.0) - frac;                  \\\n    vec2 inv2  = inv * inv;                         \\\n    /* compute basis spline */                      \\\n    vec2 w0 = 1.0/6.0 * inv2 * inv;                 \\\n    vec2 w1 = 2.0/3.0 - 0.5 * frac2 * (2.0 - frac); \\\n    vec2 w2 = 2.0/3.0 - 0.5 * inv2  * (2.0 - inv);  \\\n    vec2 w3 = 1.0/6.0 * frac2 * frac;               \\\n    vec4 g = vec4(w0 + w1, w2 + w3);                \\\n    vec4 h = vec4(w1, w3) / g + inv.xyxy;           \\\n    h.xy -= vec2(2.0);                              \\\n    /* sample four corners, then interpolate */     \\\n    vec4 p = pos.xyxy + $pt.xyxy * h;               \\\n    vec4 c00 = textureLod($tex, p.xy, 0.0);         \\\n    vec4 c01 = textureLod($tex, p.xw, 0.0);         \\\n    vec4 c0 = mix(c01, c00, g.y);                   \\\n    vec4 c10 = textureLod($tex, p.zy, 0.0);         \\\n    vec4 c11 = textureLod($tex, p.zw, 0.0);         \\\n    vec4 c1 = mix(c11, c10, g.y);                   \\\n    color = ${float:scale} * mix(c1, c0, g.x);      \\\n    }\n\n    return true;\n}\n</code></pre> <p>This gets transformed, by the GLSL macro preprocessor, into an optimized shader template invocation like the following:</p> <pre><code>{\n    // ...\n    sh_describe(sh, \"bicubic\");\n    const struct __attribute__((__packed__)) {\n        ident_t pos;\n        ident_t tex;\n        ident_t pt;\n        ident_t scale;\n    } _glsl_330_args = {\n        .pos = pos,\n        .tex = tex,\n        .pt = pt,\n        .scale = sh_const_float(sh, \"scale\", scale),\n    };\n    size_t _glsl_330_fn(void *, pl_str *, const uint8_t *);\n    pl_str_builder_append(sh-&gt;buffers[SH_BUF_BODY], _glsl_330_fn,\n                          &amp;_glsl_330_args, sizeof(_glsl_330_args));\n    // ...\n}\n\nsize_t _glsl_330_fn(void *alloc, pl_str *buf, const uint8_t *ptr)\n{\n    struct __attribute__((__packed__)) {\n        ident_t pos;\n        ident_t tex;\n        ident_t pt;\n        ident_t scale;\n    } vars;\n    memcpy(&amp;vars, ptr, sizeof(vars));\n\n    pl_str_append_asprintf_c(alloc, buf,\n        \"/* pl_shader_sample_bicubic */\\n\"\n        \"    vec4 color;\\n\"\n        \"    {\\n\"\n        \"    vec2 pos = /*pos*/_%hx;\\n\"\n        \"    vec2 size = vec2(textureSize(/*tex*/_%hx, 0));\\n\"\n        \"    vec2 frac  = fract(pos * size + vec2(0.5));\\n\"\n        \"    vec2 frac2 = frac * frac;\\n\"\n        \"    vec2 inv   = vec2(1.0) - frac;\\n\"\n        \"    vec2 inv2  = inv * inv;\\n\"\n        \"    /* compute basis spline */\\n\"\n        \"    vec2 w0 = 1.0/6.0 * inv2 * inv;\\n\"\n        \"    vec2 w1 = 2.0/3.0 - 0.5 * frac2 * (2.0 - frac);\\n\"\n        \"    vec2 w2 = 2.0/3.0 - 0.5 * inv2  * (2.0 - inv);\\n\"\n        \"    vec2 w3 = 1.0/6.0 * frac2 * frac;\\n\"\n        \"    vec4 g = vec4(w0 + w1, w2 + w3);\\n\"\n        \"    vec4 h = vec4(w1, w3) / g + inv.xyxy;\\n\"\n        \"    h.xy -= vec2(2.0);\\n\"\n        \"    /* sample four corners, then interpolate */\\n\"\n        \"    vec4 p = pos.xyxy + /*pt*/_%hx.xyxy * h;\\n\"\n        \"    vec4 c00 = textureLod(/*tex*/_%hx, p.xy, 0.0);\\n\"\n        \"    vec4 c01 = textureLod(/*tex*/_%hx, p.xw, 0.0);\\n\"\n        \"    vec4 c0 = mix(c01, c00, g.y);\\n\"\n        \"    vec4 c10 = textureLod(/*tex*/_%hx, p.zy, 0.0);\\n\"\n        \"    vec4 c11 = textureLod(/*tex*/_%hx, p.zw, 0.0);\\n\"\n        \"    vec4 c1 = mix(c11, c10, g.y);\\n\"\n        \"    color = /*scale*/_%hx * mix(c1, c0, g.x);\\n\"\n        \"    }\\n\",\n        vars.pos,\n        vars.tex,\n        vars.pt,\n        vars.tex,\n        vars.tex,\n        vars.tex,\n        vars.tex,\n        vars.scale\n    );\n\n    return sizeof(vars);\n}\n</code></pre> <p>To support this style of shader programming, special syntax was invented:</p>"},{"location":"glsl/#shader-variables","title":"Shader variables","text":"<p>Instead of being formatted with <code>\"$\"</code>, <code>%f</code> etc. and supplied in a big list, printf style, GLSL macros may directly embed shader variables:</p> <pre><code>ident_t pos, tex = sh_bind(sh, texture, ..., &amp;pos, ...);\n#pragma GLSL vec4 color = texture($tex, $pos);\n</code></pre> <p>The simplest possible shader variable is just <code>$name</code>, which corresponds to any variable of type <code>ident_t</code>. More complicated expression are also possible:</p> <pre><code>#define RAND3 ${sh_prng(sh, false, NULL)}\ncolor.rgb += ${float:params-&gt;noise} * RAND3;\n</code></pre> <p>In the expression <code>${float:params-&gt;noise}</code>, the <code>float:</code> prefix here transforms the shader variable into the equivalent of <code>SH_FLOAT()</code> in the legacy API, that is, a generic float (specialization) constant. Other possible types are:</p> <pre><code>TYPE  i = ${ident: sh_desc(...)};\nfloat f = ${float: M_PI};\nint   i = ${int:   params-&gt;width};\nuint  u = ${uint:  sizeof(ssbo)};\n</code></pre> <p>In addition to a type specifier, the optional qualifiers <code>dynamic</code> and <code>const</code> will modify the variable, turning it into (respectively) a dynamically loaded uniform (<code>SH_FLOAT_DYN</code> etc.), or a hard-coded shader literal (<code>%d</code>, <code>%f</code> etc.):</p> <pre><code>const float base = ${const float: M_LOG10E};\nint seed = ${dynamic int: rand()};\n</code></pre> <p>For sampling from component masks, the special types <code>swizzle</code> and <code>(b|u|i)vecType</code> can be used to generate the appropriate texture swizzle and corresponding vector type:</p> <pre><code>${vecType: comp_mask} tmp = color.${swizzle: comp_mask};\n</code></pre>"},{"location":"glsl/#macro-directives","title":"Macro directives","text":"<p>Lines beginning with <code>@</code> are not included in the GLSL as-is, but instead parsed as macro directives, to control the code flow inside the macro expansion:</p>"},{"location":"glsl/#if-else","title":"@if / @else","text":"<p>Standard-purpose conditional. Example:</p> <pre><code>float alpha = ...;\n@if (repr.alpha == PL_ALPHA_INDEPENDENT)\n    color.a *= alpha;\n@else\n    color.rgba *= alpha;\n</code></pre> <p>The condition is evaluated outside the macro (in the enclosing scope) and the resulting boolean variable is directly passed to the template.</p> <p>An <code>@if</code> block can also enclose multiple lines:</p> <pre><code>@if (threshold &gt; 0) {\n    float thresh = ${float:threshold};\n    coeff = mix(coeff, vec2(0.0), lessThan(coeff, vec2(thresh)));\n    coeff = mix(coeff, vec2(1.0), greaterThan(coeff, vec2(1.0 - thresh)));\n@}\n</code></pre>"},{"location":"glsl/#for","title":"@for","text":"<p>This can be used to generate (unrolled) loops:</p> <pre><code>int offset = ${const int: params-&gt;kernel_width / 2};\nfloat sum = 0.0;\n@for (x &lt; params-&gt;kernel_width)\n    sum += textureLodOffset($luma, $pos, 0.0, int(@sum - offset)).r;\n</code></pre> <p>This introduces a local variable, <code>@x</code>, which expands to an integer containing the current loop index. Loop indices always start at 0. Valid terminating conditions include <code>&lt;</code> and <code>&lt;=</code>, and the loop stop condition is also evaluated as an integer.</p> <p>Alternatively, this can be used to iterate over a bitmask (as commonly used for e.g. components in a color mask):</p> <pre><code>float weight = /* ... */;\nvec4 color = textureLod($tex, $pos, 0.0);\n@for (c : params-&gt;component_mask)\n    sum[@c] += weight * color[@c];\n</code></pre> <p>Finally, to combine loops with conditionals, the special syntax <code>@if @(cond)</code> may be used to evaluate expressions inside the template loop:</p> <pre><code>@for (i &lt; 10) {\n    float weight = /* ... */;\n    @if @(i &lt; 5)\n        weight = -weight;\n    sum += weight * texture(...);\n@}\n</code></pre> <p>In this case, the <code>@if</code> conditional may only reference local (loop) variables.</p>"},{"location":"glsl/#switch-case","title":"@switch / @case","text":"<p>This corresponds fairly straightforwardly to a normal switch/case from C:</p> <pre><code>@switch (color-&gt;transfer) {\n@case PL_COLOR_TRC_SRGB:\n    color.rgb = mix(color.rgb * 1.0/12.92,\n                    pow((color.rgb + vec3(0.055)) / 1.055, vec3(2.4)),\n                    lessThan(vec3(0.04045), color.rgb));\n    @break;\n@case PL_COLOR_TRC_GAMMA18:\n    color.rgb = pow(color.rgb, vec3(1.8));\n    @break;\n@case PL_COLOR_TRC_GAMMA20:\n    color.rgb = pow(color.rgb, vec3(2.0));\n    @break;\n@case PL_COLOR_TRC_GAMMA22:\n    color.rgb = pow(color.rgb, vec3(2.2));\n    @break;\n/* ... */\n@}\n</code></pre> <p>The switch body is always evaluated as an <code>unsigned int</code>.</p>"},{"location":"options/","title":"Options","text":"<p>The following provides an overview of all options available via the built-in <code>pl_options</code> system.</p>"},{"location":"options/#global-preset","title":"Global preset","text":""},{"location":"options/#presetdefaultfasthigh_quality","title":"<code>preset=&lt;default|fast|high_quality&gt;</code>","text":"<p>Override all options from all sections by the values from the given preset. The following presets are available:</p> <ul> <li><code>default</code>: Default settings, tuned to provide a balance of performance and   quality. Should be fine on almost all systems.</li> <li><code>fast</code>: Disable all advanced rendering, equivalent to passing <code>no</code> to every   option. Increases performance on very slow / old integrated GPUs.</li> <li><code>high_quality</code>: Reset all structs to their <code>high_quality</code> presets (where   available), set the upscaler to <code>ewa_lanczossharp</code>, and enable <code>deband=yes</code>.   Suitable for use on machines with a discrete GPU.</li> </ul>"},{"location":"options/#scaling","title":"Scaling","text":""},{"location":"options/#upscalerfilter","title":"<code>upscaler=&lt;filter&gt;</code>","text":"<p>Sets the filter used for upscaling. Defaults to <code>lanczos</code>. Pass <code>upscaler=help</code> to see a full list of filters. The most relevant options, roughly ordered from fastest to slowest:</p> <ul> <li><code>none</code>: No filter, only use basic GPU texture sampling</li> <li><code>nearest</code>: Nearest-neighbour (box) sampling (very fast)</li> <li><code>bilinear</code>: Bilinear sampling (very fast)</li> <li><code>oversample</code>: Aspect-ratio preserving nearest neighbour sampling (very fast)</li> <li><code>bicubic</code>: Bicubic interpolation (fast)</li> <li><code>gaussian</code>: Gaussian smoothing (fast)</li> <li><code>catmull_rom</code>: Catmull-Rom cubic spline</li> <li><code>lanczos</code>: Lanczos reconstruction</li> <li><code>ewa_lanczos</code>: EWA Lanczos (\"Jinc\") reconstruction (slow)</li> <li><code>ewa_lanczossharp</code>: Sharpened version of <code>ewa_lanczos</code> (slow)</li> <li><code>ewa_lanczos4sharpest</code>: Very sharp version of <code>ewa_lanczos</code>, with   anti-ringing (very slow)</li> </ul>"},{"location":"options/#downscalerfilter","title":"<code>downscaler=&lt;filter&gt;</code>","text":"<p>Sets the filter used for downscaling. Defaults to <code>hermite</code>. Pass <code>downscaler=help</code> to see a full list of filters. The most relevant options, roughly ordered from fastest to slowest:</p> <ul> <li><code>none</code>: Use the same filter as specified for <code>upscaler</code></li> <li><code>box</code>: Box averaging (very fast)</li> <li><code>hermite</code>: Hermite-weighted averaging (fast)</li> <li><code>bilinear</code>: Bilinear (triangle) averaging (fast)</li> <li><code>bicubic</code>: Bicubic interpolation (fast)</li> <li><code>gaussian</code>: Gaussian smoothing (fast)</li> <li><code>catmull_rom</code>: Catmull-Rom cubic spline</li> <li><code>mitchell</code>: Mitchell-Netravalia cubic spline</li> <li><code>lanczos</code>: Lanczos reconstruction</li> </ul>"},{"location":"options/#plane_upscalerfilter-plane_downscalerfilter","title":"<code>plane_upscaler=&lt;filter&gt;</code>, <code>plane_downscaler=&lt;filter&gt;</code>","text":"<p>Override the filter used for upscaling/downscaling planes, e.g. chroma/alpha. If set to <code>none</code>, use the same setting as <code>upscaler</code> and <code>downscaler</code>, respectively. Defaults to <code>none</code> for both.</p>"},{"location":"options/#frame_mixerfilter","title":"<code>frame_mixer=&lt;filter&gt;</code>","text":"<p>Sets the filter used for frame mixing (temporal interpolation). Defaults to <code>oversample</code>. Pass <code>frame_mixer=help</code> to see a full list of filters. The most relevant options, roughly ordered from fastest to slowest:</p> <ul> <li><code>none</code>: Disable frame mixing, show nearest frame to target PTS</li> <li><code>oversample</code>: Oversampling, only mix \"edge\" frames while preserving FPS</li> <li><code>hermite</code>: Hermite-weighted frame mixing</li> <li><code>linear</code>: Linear frame mixing</li> <li><code>cubic</code>: Cubic B-spline frame mixing</li> </ul>"},{"location":"options/#antiringing_strength0010","title":"<code>antiringing_strength=&lt;0.0..1.0&gt;</code>","text":"<p>Antiringing strength to use for all filters. A value of <code>0.0</code> disables antiringing, and a value of <code>1.0</code> enables full-strength antiringing. Defaults to <code>0.0</code>.</p> <p>Note</p> <p>Specific filter presets may override this option.</p>"},{"location":"options/#custom-scalers","title":"Custom scalers","text":"<p>Custom filter kernels can be created by setting the filter to <code>custom</code>, in addition to setting the respective options, replacing <code>&lt;scaler&gt;</code> by the corresponding scaler (<code>upscaler</code>, <code>downscaler</code>, etc.)</p>"},{"location":"options/#scaler_presetfilter","title":"<code>&lt;scaler&gt;_preset=&lt;filter&gt;</code>","text":"<p>Overrides the value of all options in this section by their default values from the given filter preset.</p>"},{"location":"options/#scaler_kernelkernel-scaler_windowkernel","title":"<code>&lt;scaler&gt;_kernel=&lt;kernel&gt;</code>, <code>&lt;scaler&gt;_window=&lt;kernel&gt;</code>","text":"<p>Choose the filter kernel and window function, rspectively. Pass <code>help</code> to get a full list of filter kernels. Defaults to <code>none</code>.</p>"},{"location":"options/#scaler_radius00160","title":"<code>&lt;scaler&gt;_radius=&lt;0.0..16.0&gt;</code>","text":"<p>Override the filter kernel radius. Has no effect if the filter kernel is not resizeable. Defaults to <code>0.0</code>, meaning \"no override\".</p>"},{"location":"options/#scaler_clamp0010","title":"<code>&lt;scaler&gt;_clamp=&lt;0.0..1.0&gt;</code>","text":"<p>Represents an extra weighting/clamping coefficient for negative weights. A value of <code>0.0</code> represents no clamping. A value of <code>1.0</code> represents full clamping, i.e. all negative lobes will be removed. Defaults to <code>0.0</code>.</p>"},{"location":"options/#scaler_blur001000","title":"<code>&lt;scaler&gt;_blur=&lt;0.0..100.0&gt;</code>","text":"<p>Additional blur coefficient. This effectively stretches the kernel, without changing the effective radius of the filter radius. Setting this to a value of <code>0.0</code> is equivalent to disabling it. Values significantly below <code>1.0</code> may seriously degrade the visual output, and should be used with care. Defaults to <code>0.0</code>.</p>"},{"location":"options/#scaler_taper0010","title":"<code>&lt;scaler&gt;_taper=&lt;0.0..1.0&gt;</code>","text":"<p>Additional taper coefficient. This essentially flattens the function's center. The values within <code>[-taper, taper]</code> will return <code>1.0</code>, with the actual function being squished into the remainder of <code>[taper, radius]</code>. Defaults to <code>0.0</code>.</p>"},{"location":"options/#scaler_antiring0010","title":"<code>&lt;scaler&gt;_antiring=&lt;0.0..1.0&gt;</code>","text":"<p>Antiringing override for this filter. Defaults to <code>0.0</code>, which infers the value from <code>antiringing_strength</code>.</p>"},{"location":"options/#scaler_param1-scaler_param2-scaler_wparam1-scaler_wparam2","title":"<code>&lt;scaler&gt;_param1</code>, <code>&lt;scaler&gt;_param2</code> <code>&lt;scaler&gt;_wparam1</code>, <code>&lt;scaler&gt;_wparam2</code>","text":"<p>Parameters for the respective filter function. Ignored if not tunable. Defaults to <code>0.0</code>.</p>"},{"location":"options/#scaler_polaryesno","title":"<code>&lt;scaler&gt;_polar=&lt;yes|no&gt;</code>","text":"<p>If true, this filter is a polar/2D filter (EWA), instead of a separable/1D (orthogonal) filter. Defaults to <code>no</code>.</p>"},{"location":"options/#debanding","title":"Debanding","text":"<p>These options control the optional debanding step. Debanding can be used to reduce the prevalence of quantization artefacts in low quality sources, but can be heavy to compute on weaker devices.</p> <p>Note</p> <p>This can also be used as a pure grain generator, by setting <code>deband_iterations=0</code>.</p>"},{"location":"options/#debandyesno","title":"<code>deband=&lt;yes|no&gt;</code>","text":"<p>Enables debanding. Defaults to <code>no</code>.</p>"},{"location":"options/#deband_presetdefault","title":"<code>deband_preset=&lt;default&gt;</code>","text":"<p>Overrides the value of all options in this section by their default values from the given preset.</p>"},{"location":"options/#deband_iterations016","title":"<code>deband_iterations=&lt;0..16&gt;</code>","text":"<p>The number of debanding steps to perform per sample. Each step reduces a bit more banding, but takes time to compute. Note that the strength of each step falls off very quickly, so high numbers (&gt;4) are practically useless. Defaults to <code>1</code>.</p>"},{"location":"options/#deband_threshold0010000","title":"<code>deband_threshold=&lt;0.0..1000.0&gt;</code>","text":"<p>The debanding filter's cut-off threshold. Higher numbers increase the debanding strength dramatically, but progressively diminish image details. Defaults to <code>3.0</code>.</p>"},{"location":"options/#deband_radius0010000","title":"<code>deband_radius=&lt;0.0..1000.0&gt;</code>","text":"<p>The debanding filter's initial radius. The radius increases linearly for each iteration. A higher radius will find more gradients, but a lower radius will smooth more aggressively. Defaults to <code>16.0</code>.</p>"},{"location":"options/#deband_grain0010000","title":"<code>deband_grain=&lt;0.0..1000.0&gt;</code>","text":"<p>Add some extra noise to the image. This significantly helps cover up remaining quantization artifacts. Higher numbers add more noise. Defaults to <code>4.0</code>, which is very mild.</p>"},{"location":"options/#deband_grain_neutral_r-deband_grain_neutral_g-deband_grain_neutral_b","title":"<code>deband_grain_neutral_r, deband_grain_neutral_g, deband_grain_neutral_b</code>","text":"<p>'Neutral' grain value for each channel being debanded. Grain application will be modulated to avoid disturbing colors close to this value. Set this to a value corresponding to black in the relevant colorspace.</p> <p>Note</p> <p>This is done automatically by <code>pl_renderer</code> and should not need to be touched by the user. This is purely a debug option.</p>"},{"location":"options/#sigmoidization","title":"Sigmoidization","text":"<p>These options control the sigmoidization parameters. Sigmoidization is an optional step during upscaling which reduces the prominence of ringing artifacts.</p>"},{"location":"options/#sigmoidyesno","title":"<code>sigmoid=&lt;yes|no&gt;</code>","text":"<p>Enables sigmoidization. Defaults to <code>yes</code>.</p>"},{"location":"options/#sigmoid_presetdefault","title":"<code>sigmoid_preset=&lt;default&gt;</code>","text":"<p>Overrides the value of all options in this section by their default values from the given preset.</p>"},{"location":"options/#sigmoid_center0010","title":"<code>sigmoid_center=&lt;0.0..1.0&gt;</code>","text":"<p>The center (bias) of the sigmoid curve. Defaults to <code>0.75</code>.</p>"},{"location":"options/#sigmoid_slope10200","title":"<code>sigmoid_slope=&lt;1.0..20.0&gt;</code>","text":"<p>The slope (steepness) of the sigmoid curve. Defaults to <code>6.5</code>.</p>"},{"location":"options/#color-adjustment","title":"Color adjustment","text":"<p>These options affect the decoding of the source color values, and can be used to subjectively alter the appearance of the video.</p>"},{"location":"options/#color_adjustmentyesno","title":"<code>color_adjustment=&lt;yes|no&gt;</code>","text":"<p>Enables color adjustment. Defaults to <code>yes</code>.</p>"},{"location":"options/#color_adjustment_presetneutral","title":"<code>color_adjustment_preset=&lt;neutral&gt;</code>","text":"<p>Overrides the value of all options in this section by their default values from the given preset.</p>"},{"location":"options/#brightness-1010","title":"<code>brightness=&lt;-1.0..1.0&gt;</code>","text":"<p>Brightness boost. Adds a constant bias onto the source luminance signal. <code>0.0</code> = neutral, <code>1.0</code> = solid white, <code>-1.0</code> = solid black. Defaults to <code>0.0</code>.</p>"},{"location":"options/#contrast001000","title":"<code>contrast=&lt;0.0..100.0&gt;</code>","text":"<p>Contrast gain. Multiplies the source luminance signal by a constant factor. <code>1.0</code> = neutral, <code>0.0</code> = solid black. Defaults to <code>1.0</code>.</p>"},{"location":"options/#saturation001000","title":"<code>saturation=&lt;0.0..100.0&gt;</code>","text":"<p>Saturation gain. Multiplies the source chromaticity signal by a constant factor. <code>1.0</code> = neutral, <code>0.0</code> = grayscale. Defaults to <code>1.0</code>.</p>"},{"location":"options/#hueangle","title":"<code>hue=&lt;angle&gt;</code>","text":"<p>Hue shift. Corresponds to a rotation of the UV subvector around the neutral axis. Specified in radians. Defaults to <code>0.0</code> (neutral).</p>"},{"location":"options/#gamma001000","title":"<code>gamma=&lt;0.0..100.0&gt;</code>","text":"<p>Gamma lift. Subjectively brightnes or darkens the scene while preserving overall contrast. <code>1.0</code> = neutral, <code>0.0</code> = solid black. Defaults to <code>1.0</code>.</p>"},{"location":"options/#temperature-11435286","title":"<code>temperature=&lt;-1.143..5.286&gt;</code>","text":"<p>Color temperature shift. Relative to 6500 K, a value of <code>0.0</code> gives you 6500 K (no change), a value of <code>-1.0</code> gives you 3000 K, and a value of <code>1.0</code> gives you 10000 K. Defaults to <code>0.0</code>.</p>"},{"location":"options/#hdr-peak-detection","title":"HDR peak detection","text":"<p>These options affect the HDR peak detection step. This can be used to greatly improve the HDR tone-mapping process in the absence of dynamic video metadata, but may be prohibitively slow on some devices (e.g. weaker integrated GPUs).</p>"},{"location":"options/#peak_detectyesno","title":"<code>peak_detect=&lt;yes|no&gt;</code>","text":"<p>Enables HDR peak detection. Defaults to <code>yes</code>.</p>"},{"location":"options/#peak_detection_presetdefaulthigh_quality","title":"<code>peak_detection_preset=&lt;default|high_quality&gt;</code>","text":"<p>Overrides the value of all options in this section by their default values from the given preset. <code>high_quality</code> also enables frame histogram measurement.</p>"},{"location":"options/#peak_smoothing_period0010000","title":"<code>peak_smoothing_period=&lt;0.0..1000.0&gt;</code>","text":"<p>Smoothing coefficient for the detected values. This controls the time parameter (tau) of an IIR low pass filter. In other words, it represent the cutoff period (= 1 / cutoff frequency) in frames. Frequencies below this length will be suppressed. This helps block out annoying \"sparkling\" or \"flickering\" due to small variations in frame-to-frame brightness. If left as <code>0.0</code>, this smoothing is completely disabled. Defaults to <code>20.0</code>.</p>"},{"location":"options/#scene_threshold_low001000-scene_threshold_high001000","title":"<code>scene_threshold_low=&lt;0.0..100.0&gt;</code>, <code>scene_threshold_high=&lt;0.0..100.0&gt;</code>","text":"<p>In order to avoid reacting sluggishly on scene changes as a result of the low-pass filter, we disable it when the difference between the current frame brightness and the average frame brightness exceeds a given threshold difference. But rather than a single hard cutoff, which would lead to weird discontinuities on fades, we gradually disable it over a small window of brightness ranges. These parameters control the lower and upper bounds of this window, in units of 1% PQ.</p> <p>Setting either one of these to 0.0 disables this logic. Defaults to <code>1.0</code> and <code>3.0</code>, respectively.</p>"},{"location":"options/#peak_percentile001000","title":"<code>peak_percentile=&lt;0.0..100.0&gt;</code>","text":"<p>Which percentile of the input image brightness histogram to consider as the true peak of the scene. If this is set to <code>100</code> (or <code>0</code>), the brightest pixel is measured. Otherwise, the top of the frequency distribution is progressively cut off. Setting this too low will cause clipping of very bright details, but can improve the dynamic brightness range of scenes with very bright isolated highlights.</p> <p>Defaults to <code>100.0</code>. The <code>high_quality</code> preset instead sets this to <code>99.995</code>, which is very conservative and should cause no major issues in typical content.</p>"},{"location":"options/#black_cutoff001000","title":"<code>black_cutoff=&lt;0.0..100.0&gt;</code>","text":"<p>Black cutoff strength. To prevent unnatural pixel shimmer and excessive darkness in mostly black scenes, as well as avoid black bars from affecting the content, (smoothly) cut off any value below this (PQ%) threshold. Defaults to <code>1.0</code>, or 1% PQ.</p> <p>Setting this to <code>0.0</code> (or a negative value) disables this functionality.</p>"},{"location":"options/#allow_delayed_peakyesno","title":"<code>allow_delayed_peak=&lt;yes|no&gt;</code>","text":"<p>Allows the peak detection result to be delayed by up to a single frame, which can sometimes improve thoughput, at the cost of introducing the possibility of 1-frame flickers on transitions. Defaults to <code>no</code>.</p>"},{"location":"options/#color-mapping","title":"Color mapping","text":"<p>These options affect the way colors are transformed between color spaces, including tone- and gamut-mapping where needed.</p>"},{"location":"options/#color_mapyesno","title":"<code>color_map=&lt;yes|no&gt;</code>","text":"<p>Enables the use of these color mapping settings. Defaults to <code>yes</code>.</p> <p>Note</p> <p>Disabling this option does not disable color mapping, it just means \"use the default options for everything\".</p>"},{"location":"options/#color_map_presetdefaulthigh_quality","title":"<code>color_map_preset=&lt;default|high_quality&gt;</code>","text":"<p>Overrides the value of all options in this section by their default values from the given preset. <code>high_quality</code> also enables HDR contrast recovery.</p>"},{"location":"options/#gamut_mappingfunction","title":"<code>gamut_mapping=&lt;function&gt;</code>","text":"<p>Gamut mapping function to use to handle out-of-gamut colors, including colors which are out-of-gamut as a consequence of tone mapping. Defaults to <code>perceptual</code>. The following options are available:</p> <ul> <li><code>clip</code>: Performs no gamut-mapping, just hard clips out-of-range colors   per-channel.</li> <li><code>perceptual</code>: Performs a perceptually balanced (saturation) gamut mapping,   using a soft knee function to preserve in-gamut colors, followed by a final   softclip operation. This works bidirectionally, meaning it can both compress   and expand the gamut. Behaves similar to a blend of <code>saturation</code> and   <code>softclip</code>.</li> <li><code>softclip</code>: Performs a perceptually balanced gamut mapping using a soft knee   function to roll-off clipped regions, and a hue shifting function to preserve   saturation.</li> <li><code>relative</code>: Performs relative colorimetric clipping, while maintaining an   exponential relationship between brightness and chromaticity.</li> <li><code>saturation</code>: Performs simple RGB-&gt;RGB saturation mapping. The input R/G/B   channels are mapped directly onto the output R/G/B channels. Will never clip,   but will distort all hues and/or result in a faded look.</li> <li><code>absolute</code>: Performs absolute colorimetric clipping. Like <code>relative</code>, but   does not adapt the white point.</li> <li><code>desaturate</code>: Performs constant-luminance colorimetric clipping, desaturing   colors towards white until they're in-range.</li> <li><code>darken</code>: Uniformly darkens the input slightly to prevent clipping on   blown-out highlights, then clamps colorimetrically to the input gamut   boundary, biased slightly to preserve chromaticity over luminance.</li> <li><code>highlight</code>: Performs no gamut mapping, but simply highlights out-of-gamut   pixels.</li> <li><code>linear</code>: Linearly/uniformly desaturates the image in order to bring the   entire image into the target gamut.</li> </ul>"},{"location":"options/#gamut-mapping-constants","title":"Gamut mapping constants","text":"<p>These settings can be used to fine-tune the constants used for the various gamut mapping algorithms.</p>"},{"location":"options/#perceptual_deadzone0010","title":"<code>perceptual_deadzone=&lt;0.0..1.0&gt;</code>","text":"<p>(Relative) chromaticity protection zone for <code>perceptual</code> mapping. Defaults to <code>0.30</code>.</p>"},{"location":"options/#perceptual_strength0010","title":"<code>perceptual_strength=&lt;0.0..1.0&gt;</code>","text":"<p>Strength of the <code>perceptual</code> saturation mapping component. Defaults to <code>0.80</code>.</p>"},{"location":"options/#colorimetric_gamma00100","title":"<code>colorimetric_gamma=&lt;0.0..10.0&gt;</code>","text":"<p>I vs C curve gamma to use for colorimetric clipping (<code>relative</code>, <code>absolute</code> and <code>darken</code>). Defaults to <code>1.80</code>.</p>"},{"location":"options/#softclip_knee0010","title":"<code>softclip_knee=&lt;0.0..1.0&gt;</code>","text":"<p>Knee point to use for soft-clipping methods (<code>perceptual</code>, <code>softclip</code>). Defaults to <code>0.70</code>.</p>"},{"location":"options/#softclip_desat0010","title":"<code>softclip_desat=&lt;0.0..1.0&gt;</code>","text":"<p>Desaturation strength for <code>softclip</code>. Defaults to <code>0.35</code>.</p>"},{"location":"options/#lut3d_size_i01024-lut3d_size_c01024-lut3d_size_h01024","title":"<code>lut3d_size_I=&lt;0..1024&gt;</code>, <code>lut3d_size_C=&lt;0..1024&gt;</code>, <code>lut3d_size_h=&lt;0..1024&gt;</code>","text":"<p>Gamut mapping 3DLUT size. Setting a dimension to <code>0</code> picks the default value. Defaults to <code>48</code>, <code>32</code> and <code>256</code>, respectively, for channels <code>I</code>, <code>C</code> and <code>h</code>.</p>"},{"location":"options/#lut3d_tricubicyesno","title":"<code>lut3d_tricubic=&lt;yes|no&gt;</code>","text":"<p>Use higher quality, but slower, tricubic interpolation for gamut mapping 3DLUTs. May substantially improve the 3DLUT gamut mapping accuracy, in particular at smaller 3DLUT sizes. Shouldn't have much effect at the default size. Defaults to <code>no</code>.</p>"},{"location":"options/#gamut_expansionyesno","title":"<code>gamut_expansion=&lt;yes|no&gt;</code>","text":"<p>If enabled, allows the gamut mapping function to expand the gamut, in cases where the target gamut exceeds that of the source. If disabled, the source gamut will never be enlarged, even when using a gamut mapping function capable of bidirectional mapping. Defaults to <code>no</code>.</p>"},{"location":"options/#tone_mappingfunction","title":"<code>tone_mapping=&lt;function&gt;</code>","text":"<p>Tone mapping function to use for adapting between difference luminance ranges, including black point adaptation. Defaults to <code>spline</code>. The following functions are available:</p> <ul> <li><code>clip</code>: Performs no tone-mapping, just clips out-of-range colors. Retains   perfect color accuracy for in-range colors but completely destroys   out-of-range information. Does not perform any black point adaptation.</li> <li><code>spline</code>: Simple spline consisting of two polynomials, joined by a single   pivot point, which is tuned based on the source scene average brightness   (taking into account dynamic metadata if available). This function can be   used for both forward and inverse tone mapping.</li> <li><code>st2094-40</code>: EETF from SMPTE ST 2094-40 Annex B, which uses the provided OOTF   based on Bezier curves to perform tone-mapping. The OOTF used is adjusted   based on the ratio between the targeted and actual display peak luminances.   In the absence of HDR10+ metadata, falls back to a simple constant bezier   curve.</li> <li><code>st2094-10</code>: EETF from SMPTE ST 2094-10 Annex B.2, which takes into account   the input signal average luminance in addition to the maximum/minimum.</li> </ul> <p>Warning</p> <p>This does not currently include the subjective gain/offset/gamma controls defined in Annex B.3. (Open an issue with a valid sample file if you want such parameters to be respected.)</p> <ul> <li><code>bt2390</code>: EETF from the ITU-R Report BT.2390, a hermite spline roll-off with   linear segment.</li> <li><code>bt2446a</code>: EETF from ITU-R Report BT.2446, method A. Can be used for both   forward and inverse tone mapping.</li> <li><code>reinhard:</code> Very simple non-linear curve. Named after Erik Reinhard.</li> <li><code>mobius</code>: Generalization of the <code>reinhard</code> tone mapping algorithm to support   an additional linear slope near black. The name is derived from its function   shape <code>(ax+b)/(cx+d)</code>, which is known as a M\u00f6bius transformation. This   function is considered legacy/low-quality, and should not be used.</li> <li><code>hable</code>: Piece-wise, filmic tone-mapping algorithm developed by John Hable   for use in Uncharted 2, inspired by a similar tone-mapping algorithm used by   Kodak. Popularized by its use in video games with HDR rendering. Preserves   both dark and bright details very well, but comes with the drawback of   changing the average brightness quite significantly. This is sort of similar   to <code>reinhard</code> with <code>reinhard_contrast=0.24</code>. This function is considered   legacy/low-quality, and should not be used.</li> <li><code>gamma</code>: Fits a gamma (power) function to transfer between the source and   target color spaces, effectively resulting in a perceptual hard-knee joining   two roughly linear sections. This preserves details at all scales, but can   result in an image with a muted or dull appearance. This function   is considered legacy/low-quality and should not be used.</li> <li><code>linear</code>: Linearly stretches the input range to the output range, in PQ   space. This will preserve all details accurately, but results in a   significantly different average brightness. Can be used for inverse   tone-mapping in addition to regular tone-mapping.</li> <li><code>linearlight</code>: Like <code>linear</code>, but in linear light (instead of PQ). Works well   for small range adjustments but may cause severe darkening when   downconverting from e.g. 10k nits to SDR.</li> </ul>"},{"location":"options/#tone-mapping-constants","title":"Tone-mapping constants","text":"<p>These settings can be used to fine-tune the constants used for the various tone mapping algorithms.</p>"},{"location":"options/#knee_adaptation0010","title":"<code>knee_adaptation=&lt;0.0..1.0&gt;</code>","text":"<p>Configures the knee point, as a ratio between the source average and target average (in PQ space). An adaptation of <code>1.0</code> always adapts the source scene average brightness to the (scaled) target average, while a value of <code>0.0</code> never modifies scene brightness.</p> <p>Affects all methods that use the ST2094 knee point determination (currently <code>spline</code>, <code>st2094-40</code> and <code>st2094-10</code>). Defaults to <code>0.4</code>.</p>"},{"location":"options/#knee_minimum0005-knee_maximum0510","title":"<code>knee_minimum=&lt;0.0..0.5&gt;</code>, <code>knee_maximum=&lt;0.5..1.0&gt;</code>","text":"<p>Configures the knee point minimum and maximum, respectively, as a percentage of the PQ luminance range. Provides a hard limit on the knee point chosen by <code>knee_adaptation</code>. Defaults to <code>0.1</code> and <code>0.8</code>, respectively.</p>"},{"location":"options/#knee_default0010","title":"<code>knee_default=&lt;0.0..1.0&gt;</code>","text":"<p>Default knee point to use in the absence of source scene average metadata. Normally, this is ignored in favor of picking the knee point as the (relative) source scene average brightness level. Defaults to <code>0.4</code>.</p>"},{"location":"options/#knee_offset0520","title":"<code>knee_offset=&lt;0.5..2.0&gt;</code>","text":"<p>Knee point offset (for <code>bt2390</code> only). Note that a value of <code>0.5</code> is the spec-defined default behavior, which differs from the libplacebo default of <code>1.0</code>.</p>"},{"location":"options/#slope_tuning00100-slope_offset0010","title":"<code>slope_tuning=&lt;0.0..10.0&gt;</code>, <code>slope_offset=&lt;0.0..1.0&gt;</code>","text":"<p>For the single-pivot polynomial (spline) function, this controls the coefficients used to tune the slope of the curve. This tuning is designed to make the slope closer to <code>1.0</code> when the difference in peaks is low, and closer to linear when the difference between peaks is high. Defaults to <code>1.5</code>, with offset <code>0.2</code>.</p>"},{"location":"options/#spline_contrast0015","title":"<code>spline_contrast=&lt;0.0..1.5&gt;</code>","text":"<p>Contrast setting for the <code>spline</code> function. Higher values make the curve steeper (closer to <code>clip</code>), preserving midtones at the cost of losing shadow/highlight details, while lower values make the curve shallowed (closer to <code>linear</code>), preserving highlights at the cost of losing midtone contrast. Values above <code>1.0</code> are possible, resulting in an output with more contrast than the input. Defaults to <code>0.5</code>.</p>"},{"location":"options/#reinhard_contrast0010","title":"<code>reinhard_contrast=&lt;0.0..1.0&gt;</code>","text":"<p>For the <code>reinhard</code> function, this specifies the local contrast coefficient at the display peak. Essentially, a value of <code>0.5</code> implies that the reference white will be about half as bright as when clipping. Defaults to <code>0.5</code>.</p>"},{"location":"options/#linear_knee0010","title":"<code>linear_knee=&lt;0.0..1.0&gt;</code>","text":"<p>For legacy functions (<code>mobius</code>, <code>gamma</code>) which operate on linear light, this directly sets the corresponding knee point. Defaults to <code>0.3</code>.</p>"},{"location":"options/#exposure00100","title":"<code>exposure=&lt;0.0..10.0&gt;</code>","text":"<p>For linear methods (<code>linear</code>, <code>linearlight</code>), this controls the linear exposure/gain applied to the image. Defaults to <code>1.0</code>.</p>"},{"location":"options/#inverse_tone_mappingyesno","title":"<code>inverse_tone_mapping=&lt;yes|no&gt;</code>","text":"<p>If enabled, and supported by the given tone mapping function, will perform inverse tone mapping to expand the dynamic range of a signal. libplacebo is not liable for any HDR-induced eye damage. Defaults to <code>no</code>.</p>"},{"location":"options/#tone_map_metadataanynonehdr10hdr10pluscie_y","title":"<code>tone_map_metadata=&lt;any|none|hdr10|hdr10plus|cie_y&gt;</code>","text":"<p>Data source to use when tone-mapping. Setting this to a specific value allows overriding the default metadata preference logic. Defaults to <code>any</code>.</p>"},{"location":"options/#tone_lut_size04096","title":"<code>tone_lut_size=&lt;0..4096&gt;</code>","text":"<p>Tone mapping LUT size. Setting <code>0</code> picks the default size. Defaults to <code>256</code>.</p>"},{"location":"options/#contrast_recovery0020","title":"<code>contrast_recovery=&lt;0.0..2.0&gt;</code>","text":"<p>HDR contrast recovery strength. If set to a value above <code>0.0</code>, the source image will be divided into high-frequency and low-frequency components, and a portion of the high-frequency image is added back onto the tone-mapped output. May cause excessive ringing artifacts for some HDR sources, but can improve the subjective sharpness and detail left over in the image after tone-mapping.</p> <p>Defaults to <code>0.0</code>. The <code>high_quality</code> preset sets this to <code>0.3</code>, which is a fairly conservativee value and should subtly enhance the image quality without creating too many obvious artefacts.</p>"},{"location":"options/#contrast_smoothness10320","title":"<code>contrast_smoothness=&lt;1.0..32.0&gt;</code>","text":"<p>HDR contrast recovery lowpass kernel size. Increasing or decreasing this will affect the visual appearance substantially. Defaults to <code>3.5</code>.</p>"},{"location":"options/#debug-options","title":"Debug options","text":"<p>Miscellaneous debugging and display options related to tone/gamut mapping.</p>"},{"location":"options/#force_tone_mapping_lutyesno","title":"<code>force_tone_mapping_lut=&lt;yes|no&gt;</code>","text":"<p>Force the use of a full tone-mapping LUT even for functions that have faster pure GLSL replacements (e.g. <code>clip</code>, <code>linear</code>, <code>saturation</code>). This is a debug option. Defaults to <code>no</code>.</p>"},{"location":"options/#visualize_lutyesno","title":"<code>visualize_lut=&lt;yes|no&gt;</code>","text":"<p>Visualize the color mapping LUTs. Displays a (PQ-PQ) graph of the active tone-mapping LUT. The X axis shows PQ input values, the Y axis shows PQ output values. The tone-mapping curve is shown in green/yellow. Yellow means the brightness has been boosted from the source, dark blue regions show where the brightness has been reduced. The extra colored regions and lines indicate various monitor limits, as well a reference diagonal (neutral tone-mapping) and source scene average brightness information (if available). The background behind this shows a visualization of the gamut mapping 3DLUT, in IPT space. Iso-luminance, iso-chromaticity and iso-hue lines are highlighted (depending on the exact value of <code>visualize_theta</code>). Defaults to <code>no</code>.</p>"},{"location":"options/#visualize_lut_x0-visualize_lut_y0-visualize_lut_x0-visualize_lut_y1","title":"<code>visualize_lut_x0</code>, <code>visualize_lut_y0</code>, <code>visualize_lut_x0</code>, <code>visualize_lut_y1</code>","text":"<p>Controls where to draw the LUt visualization, relative to the rendered video. Defaults to <code>0.0</code> for <code>x0</code>/<code>y0</code>, and <code>1.0</code> for <code>x1</code>/<code>y1</code>.</p>"},{"location":"options/#visualize_hueangle-visualize_thetaangle","title":"<code>visualize_hue=&lt;angle&gt;</code>, <code>visualize_theta=&lt;angle&gt;</code>","text":"<p>Controls the rotation of the gamut 3DLUT visualization. The <code>hue</code> parameter rotates the gamut through hue space (around the <code>I</code> axis), while the <code>theta</code> parameter vertically rotates the cross section (around the <code>C</code> axis), in radians. Defaults to <code>0.0</code> for both.</p>"},{"location":"options/#show_clippingyesno","title":"<code>show_clipping=&lt;yes|no&gt;</code>","text":"<p>Graphically highlight hard-clipped pixels during tone-mapping (i.e. pixels that exceed the claimed source luminance range). Defaults to <code>no</code>.</p>"},{"location":"options/#dithering","title":"Dithering","text":"<p>These options affect the way colors are dithered before output. Dithering is always required to avoid introducing banding artefacts as a result of quantization to a lower bit depth output texture.</p>"},{"location":"options/#ditheryesno","title":"<code>dither=&lt;yes|no&gt;</code>","text":"<p>Enables dithering. Defaults to <code>yes</code>.</p>"},{"location":"options/#dither_presetdefault","title":"<code>dither_preset=&lt;default&gt;</code>","text":"<p>Overrides the value of all options in this section by their default values from the given preset.</p>"},{"location":"options/#dither_methodmethod","title":"<code>dither_method=&lt;method&gt;</code>","text":"<p>Chooses the dithering method to use. Defaults to <code>blue</code>. The following methods are available:</p> <ul> <li><code>blue</code>: Dither with blue noise. Very high quality, but requires the use of a   LUT.</li> </ul> <p>Warning</p> <p>Computing a blue noise texture with a large size can be very slow, however this only needs to be performed once. Even so, using this with a <code>dither_lut_size</code> greater than <code>6</code> is generally ill-advised.</p> <ul> <li><code>ordered_lut</code>: Dither with an ordered (bayer) dither matrix, using a LUT. Low   quality, and since this also uses a LUT, there's generally no advantage to   picking this instead of <code>blue</code>. It's mainly there for testing.</li> <li><code>ordered</code>: The same as <code>ordered</code>, but uses fixed function math instead of a   LUT. This is faster, but only supports a fixed dither matrix size of 16x16   (equivalent to <code>dither_lut_size=4</code>).</li> <li><code>white</code>: Dither with white noise. This does not require a LUT and is fairly   cheap to compute. Unlike the other modes it doesn't show any repeating   patterns either spatially or temporally, but the downside is that this is   visually fairly jarring due to the presence of low frequencies in the noise   spectrum.</li> </ul>"},{"location":"options/#dither_lut_size18","title":"<code>dither_lut_size=&lt;1..8&gt;</code>","text":"<p>For the dither methods which require the use of a LUT (<code>blue</code>, <code>ordered_lut</code>), this controls the size of the LUT (base 2). Defaults to <code>6</code>.</p>"},{"location":"options/#dither_temporalyesno","title":"<code>dither_temporal=&lt;yes|no&gt;</code>","text":"<p>Enables temporal dithering. This reduces the persistence of dithering artifacts by perturbing the dithering matrix per frame. Defaults to <code>no</code>.</p> <p>Warning</p> <p>This can cause nasty aliasing artifacts on some LCD screens.</p>"},{"location":"options/#cone-distortion","title":"Cone distortion","text":"<p>These options can be optionally used to modulate the signal in LMS space, in particular, to simulate color blindiness.</p>"},{"location":"options/#coneyesno","title":"<code>cone=&lt;yes|no&gt;</code>","text":"<p>Enables cone distortion. Defaults to <code>no</code>.</p>"},{"location":"options/#cone_presetpreset","title":"<code>cone_preset=&lt;preset&gt;</code>","text":"<p>Overrides the value of all options in this section by their default values from the given preset. The following presets are available:</p> <ul> <li><code>normal</code>: No distortion (92% of population)</li> <li><code>protanomaly</code>: Red cone deficiency (0.66% of population)</li> <li><code>protanopia</code>: Red cone absence (0.59% of population)</li> <li><code>deuteranomaly</code>: Green cone deficiency (2.7% of population)</li> <li><code>deuteranopia</code>: Green cone absence (0.56% of population)</li> <li><code>tritanomaly</code>: Blue cone deficiency (0.01% of population)</li> <li><code>tritanopia</code>: Blue cone absence (0.016% of population)</li> <li><code>monochromacy</code>: Blue cones only (&lt;0.001% of population)</li> <li><code>achromatopsia</code>: Rods only (&lt;0.0001% of population)</li> </ul>"},{"location":"options/#conesnonelmslmmslslms","title":"<code>cones=&lt;none|l|m|s|lm|ms|ls|lms&gt;</code>","text":"<p>Choose the set of cones to modulate. Defaults to <code>none</code>.</p>"},{"location":"options/#cone_strengthgain","title":"<code>cone_strength=&lt;gain&gt;</code>","text":"<p>Defect/gain coefficient to apply to these cones. <code>1.0</code> = unaffected, <code>0.0</code> = full blindness. Defaults to <code>1.0</code>. Values above <code>1.0</code> can be used to instead boost the signal going to this cone. For example, to partially counteract deuteranomaly, you could set <code>cones=m</code>, <code>cone_strength=2.0</code>. Defaults to <code>0.0</code>.</p>"},{"location":"options/#output-blending","title":"Output blending","text":"<p>These options affect the way the image is blended onto the output framebuffer.</p>"},{"location":"options/#blendyesno","title":"<code>blend=&lt;yes|no&gt;</code>","text":"<p>Enables output blending. Defaults to <code>no</code>.</p>"},{"location":"options/#blend_presetalpha_overlay","title":"<code>blend_preset=&lt;alpha_overlay&gt;</code>","text":"<p>Overrides the value of all options in this section by their default values from the given preset. Currently, the only preset is <code>alpha_overlay</code>, which corresponds to normal alpha blending.</p>"},{"location":"options/#blend_src_rgb-blend_src_alpha-blend_dst_rgb-blend_dst_alpha","title":"<code>blend_src_rgb</code>, <code>blend_src_alpha</code>, <code>blend_dst_rgb</code>, <code>blend_dst_alpha</code>","text":"<p>Choose the blending mode for each component. Defaults to <code>zero</code> for all. The following modes are available:</p> <ul> <li><code>zero</code>: Component will be unused.</li> <li><code>one</code>: Component will be added at full strength.</li> <li><code>alpha</code>: Component will be multiplied by the source alpha value.</li> <li><code>one_minus_alpha</code>: Component will be multiplied by 1 minus the source alpha.</li> </ul>"},{"location":"options/#deinterlacing","title":"Deinterlacing","text":"<p>Configures the settings used to deinterlace frames, if required.</p> <p>Note</p> <p>The use of these options requires the caller to pass extra metadata to incoming frames to link them together / mark them as fields.</p>"},{"location":"options/#deinterlaceyesno","title":"<code>deinterlace=&lt;yes|no&gt;</code>","text":"<p>Enables deinterlacing. Defaults to <code>no</code>.</p>"},{"location":"options/#deinterlace_presetdefault","title":"<code>deinterlace_preset=&lt;default&gt;</code>","text":"<p>Overrides the value of all options in this section by their default values from the given preset.</p>"},{"location":"options/#deinterlace_algoalgorithm","title":"<code>deinterlace_algo=&lt;algorithm&gt;</code>","text":"<p>Chooses the algorithm to use for deinterlacing. Defaults to <code>yadif</code>. The following algorithms are available:</p> <ul> <li><code>weave</code>: No-op deinterlacing, just sample the weaved frame un-touched.</li> <li><code>bob</code>: Naive bob deinterlacing. Doubles the field lines vertically.</li> <li><code>yadif</code>: \"Yet another deinterlacing filter\". Deinterlacer with temporal and   spatial information. Based on FFmpeg's Yadif filter algorithm, but adapted   slightly for the GPU.</li> <li><code>bwdif</code>: \"Bob weaver deinterlacing filter\". Motion-adaptive deinterlacer   based on yadif, with the use of w3fdif and cubic interpolation algorithms.</li> </ul>"},{"location":"options/#deinterlace_skip_spatialyesno","title":"<code>deinterlace_skip_spatial=&lt;yes|no&gt;</code>","text":"<p>Skip the spatial interlacing check for <code>yadif</code>. Defaults to <code>no</code>.</p>"},{"location":"options/#distortion","title":"Distortion","text":"<p>The settings in this section can be used to distort/transform the output image.</p>"},{"location":"options/#distortyesno","title":"<code>distort=&lt;yes|no&gt;</code>","text":"<p>Enables distortion. Defaults to <code>no</code>.</p>"},{"location":"options/#distort_presetdefault","title":"<code>distort_preset=&lt;default&gt;</code>","text":"<p>Overrides the value of all options in this section by their default values from the given preset.</p>"},{"location":"options/#distort_scale_x-distort_scale_y","title":"<code>distort_scale_x</code>, <code>distort_scale_y</code>","text":"<p>Scale the image in the X/Y dimension by an arbitrary factor. Corresponds to the main diagonal of the transformation matrix. Defaults to <code>1.0</code> for both.</p>"},{"location":"options/#distort_shear_x-distort_shear_y","title":"<code>distort_shear_x</code>, <code>distort_shear_y</code>","text":"<p>Adds the X/Y dimension onto the Y/X dimension (respectively), scaled by an arbitrary amount. Corresponds to the anti-diagonal of the 2x2 transformation matrix. Defaults to <code>0.0</code> for both.</p>"},{"location":"options/#distort_offset_x-distort_offset_y","title":"<code>distort_offset_x</code>, <code>distort_offset_y</code>","text":"<p>Offsets the X/Y dimensions by an arbitrary offset, relative to the image size. Corresponds to the bottom row of a 3x3 affine transformation matrix. Defaults to <code>0.0</code> for both.</p>"},{"location":"options/#distort_unscaledyesno","title":"<code>distort_unscaled=&lt;yes|no&gt;</code>","text":"<p>If enabled, the texture is placed inside the center of the canvas without scaling. Otherwise, it is effectively stretched to the canvas size. Defaults to <code>no</code>.</p> <p>Note</p> <p>This option has no effect when using <code>pl_renderer</code>.</p>"},{"location":"options/#distort_constrainyesno","title":"<code>distort_constrain=&lt;yes|no&gt;</code>","text":"<p>If enabled, the transformation is automatically scaled down and shifted to ensure that the resulting image fits inside the output canvas. Defaults to <code>no</code>.</p>"},{"location":"options/#distort_bicubicyesno","title":"<code>distort_bicubic=&lt;yes|no&gt;</code>","text":"<p>If enabled, use bicubic interpolation rather than faster bilinear interpolation. Higher quality but slower. Defaults to <code>no</code>.</p>"},{"location":"options/#distort_addreess_modeclamprepeatmirror","title":"<code>distort_addreess_mode=&lt;clamp|repeat|mirror&gt;</code>","text":"<p>Specifies the texture address mode to use when sampling out of bounds. Defaults to <code>clamp</code>.</p>"},{"location":"options/#distort_alpha_modenoneindependentpremultiplied","title":"<code>distort_alpha_mode=&lt;none|independent|premultiplied&gt;</code>","text":"<p>If set to something other than <code>none</code>, all out-of-bounds accesses will instead be treated as transparent, according to the given alpha mode.</p>"},{"location":"options/#miscellaneous-renderer-settings","title":"Miscellaneous renderer settings","text":""},{"location":"options/#error_diffusionkernel","title":"<code>error_diffusion=&lt;kernel&gt;</code>","text":"<p>Enables error diffusion dithering. Error diffusion is a very slow and memory intensive method of dithering without the use of a fixed dither pattern. If set, this will be used instead of <code>dither_method</code> whenever possible. It's highly recommended to use this only for still images, not moving video. Defaults to <code>none</code>. The following options are available:</p> <ul> <li><code>simple</code>: Simple error diffusion (fast)</li> <li><code>false-fs</code>: False Floyd-Steinberg kernel (fast)</li> <li><code>sierra-lite</code>: Sierra Lite kernel (slow)</li> <li><code>floyd-steinberg</code>: Floyd-Steinberg kernel (slow)</li> <li><code>atkinson</code>: Atkinson kernel (slow)</li> <li><code>jarvis-judice-ninke</code>: Jarvis, Judice &amp; Ninke kernel (very slow)</li> <li><code>stucki</code>: Stucki kernel (very slow)</li> <li><code>burkes</code>: Burkes kernel (very slow)</li> <li><code>sierra-2</code>: Two-row Sierra (very slow)</li> <li><code>sierra-3</code>: Three-row Sierra (very slow)</li> </ul>"},{"location":"options/#lut_typetype","title":"<code>lut_type=&lt;type&gt;</code>","text":"<p>Overrides the color mapping LUT type. Defaults to <code>unknown</code>. The following options are available:</p> <ul> <li><code>unknown</code>: Unknown LUT type, try and guess from metadata</li> <li><code>native</code>: LUT is applied to raw image contents</li> <li><code>normalized</code>: LUT is applied to normalized (HDR) RGB values</li> <li><code>conversion</code>: LUT fully replaces color conversion step</li> </ul> <p>Note</p> <p>There is no way to load LUTs via the options mechanism, so this option only has an effect if the LUT is loaded via external means.</p>"},{"location":"options/#background_r0010-background_g0010-background_b0010","title":"<code>background_r=&lt;0.0..1.0&gt;</code>, <code>background_g=&lt;0.0..1.0&gt;</code>, <code>background_b=&lt;0.0..1.0&gt;</code>","text":"<p>If the image being rendered does not span the entire size of the target, it will be cleared explicitly using this background color (RGB). Defaults to <code>0.0</code> for all.</p>"},{"location":"options/#background_transparency0010","title":"<code>background_transparency=&lt;0.0..1.0&gt;</code>","text":"<p>The (inverted) alpha value of the background clear color. Defaults to <code>0.0</code>.</p>"},{"location":"options/#skip_target_clearingyesno","title":"<code>skip_target_clearing=&lt;yes|no&gt;</code>","text":"<p>If set, skips clearing the background backbuffer entirely. Defaults to <code>no</code>.</p> <p>Note</p> <p>This is automatically skipped if the image to be rendered would completely cover the backbuffer.</p>"},{"location":"options/#corner_rounding0010","title":"<code>corner_rounding=&lt;0.0..1.0&gt;</code>","text":"<p>If set to a value above <code>0.0</code>, the output will be rendered with rounded corners, as if an alpha transparency mask had been applied. The value indicates the relative fraction of the side length to round - a value of <code>1.0</code> rounds the corners as much as possible. Defaults to <code>0.0</code>.</p>"},{"location":"options/#blend_against_tilesyesno","title":"<code>blend_against_tiles=&lt;yes|no&gt;</code>","text":"<p>If true, then transparent images will made opaque by painting them against a checkerboard pattern consisting of alternating colors. Defaults to <code>no</code>.</p>"},{"location":"options/#tile_color_hi_r-tile_color_hi_g-tile_color_hi_b-tile_color_lo_r-tile_color_lo_g-tile_color_l_b","title":"<code>tile_color_hi_r</code>, <code>tile_color_hi_g</code>, <code>tile_color_hi_b</code>, <code>tile_color_lo_r</code>, <code>tile_color_lo_g</code>, <code>tile_color_l_b</code>","text":"<p>The colors of the light/dark tiles used for <code>blend_against_tiles</code>. Defaults to <code>0.93</code> for light R/G/B and <code>0.87</code> for dark R/G/B, respectively.</p>"},{"location":"options/#tile_size2256","title":"<code>tile_size=&lt;2..256&gt;</code>","text":"<p>The size, in output pixels, of the tiles used for <code>blend_against_tiles</code>. Defaults to <code>32</code>.</p>"},{"location":"options/#performance-quality-trade-offs","title":"Performance / quality trade-offs","text":"<p>These should generally be left off where quality is desired, as they can degrade the result quite noticeably; but may be useful for older or slower hardware. Note that libplacebo will automatically disable advanced features on hardware where they are unsupported, regardless of these settings. So only enable them if you need a performance bump.</p>"},{"location":"options/#skip_anti_aliasingyesno","title":"<code>skip_anti_aliasing=&lt;yes|no&gt;</code>","text":"<p>Disables anti-aliasing on downscaling. This will result in moir\u00e9 artifacts and nasty, jagged pixels when downscaling, except for some very limited special cases (e.g. bilinear downsampling to exactly 0.5x). Significantly speeds up downscaling with high downscaling ratios. Defaults to <code>no</code>.</p>"},{"location":"options/#preserve_mixing_cacheyesno","title":"<code>preserve_mixing_cache=&lt;yes|no&gt;</code>","text":"<p>Normally, when the size of the target framebuffer changes, or the render parameters are updated, the internal cache of mixed frames must be discarded in order to re-render all required frames. Setting this option to <code>yes</code> will skip the cache invalidation and instead re-use the existing frames (with bilinear scaling to the new size if necessary). This comes at a hefty quality loss shortly after a resize, but should make it much more smooth. Defaults to <code>no</code>.</p>"},{"location":"options/#debugging-tuning-and-testing","title":"Debugging, tuning and testing","text":"<p>These may affect performance or may make debugging problems easier, but shouldn't have any effect on the quality (except where otherwise noted).</p>"},{"location":"options/#skip_caching_single_frameyesno","title":"<code>skip_caching_single_frame=&lt;yes|no&gt;</code>","text":"<p>Normally, single frames will also get pushed through the mixer cache, in order to speed up re-draws. Enabling this option disables that logic, causing single frames to bypass being written to the cache. Defaults to <code>no</code>.</p> <p>Note</p> <p>If a frame is already cached, it will be re-used, regardless.</p>"},{"location":"options/#disable_linear_scalingyesno","title":"<code>disable_linear_scaling=&lt;yes|no&gt;</code>","text":"<p>Disables linearization / sigmoidization before scaling. This might be useful when tracking down unexpected image artifacts or excessing ringing, but it shouldn't normally be necessary. Defaults to <code>no</code>.</p>"},{"location":"options/#disable_builtin_scalersyesno","title":"<code>disable_builtin_scalers=&lt;yes|no&gt;</code>","text":"<p>Forces the use of the slower, \"general\" scaling algorithms even when faster built-in replacements exist. Defaults to <code>no</code>.</p>"},{"location":"options/#correct_subpixel_offsetsyesno","title":"<code>correct_subpixel_offsets=&lt;yes|no&gt;</code>","text":"<p>Forces correction of subpixel offsets (using the configured <code>upscaler</code>). Defaults to <code>no</code>.</p> <p>Warning</p> <p>Enabling this may cause such images to get noticeably blurrier, especially when using a polar scaler. It's not generally recommended to enable this.</p>"},{"location":"options/#force_ditheryesno","title":"<code>force_dither=&lt;yes|no&gt;</code>","text":"<p>Forces the use of dithering, even when rendering to 16-bit FBOs. This is generally pretty pointless because most 16-bit FBOs have high enough depth that rounding errors are below the human perception threshold, but this can be used to test the dither code. Defaults to <code>no</code>.</p>"},{"location":"options/#disable_dither_gamma_correctionyesno","title":"<code>disable_dither_gamma_correction=&lt;yes|no&gt;</code>","text":"<p>Disables the gamma-correct dithering logic which normally applies when dithering to low bit depths. No real use, outside of testing. Defaults to <code>no</code>.</p>"},{"location":"options/#disable_fbosyesno","title":"<code>disable_fbos=&lt;yes|no&gt;</code>","text":"<p>Completely overrides the use of FBOs, as if there were no renderable texture format available. This disables most features. Defaults to <code>no</code>.</p>"},{"location":"options/#force_low_bit_depth_fbosyesno","title":"<code>force_low_bit_depth_fbos=&lt;yes|no&gt;</code>","text":"<p>Use only low-bit-depth FBOs (8 bits). Note that this also implies disabling linear scaling and sigmoidization. Defaults to <code>no</code>.</p>"},{"location":"options/#dynamic_constantsyesno","title":"<code>dynamic_constants=&lt;yes|no&gt;</code>","text":"<p>If this is enabled, all shaders will be generated as \"dynamic\" shaders, with any compile-time constants being replaced by runtime-adjustable values. This is generally a performance loss, but has the advantage of being able to freely change parameters without triggering shader recompilations. It's a good idea to enable this if you will change these options very frequently, but it should be disabled once those values are \"dialed in\". Defaults to <code>no</code>.</p>"},{"location":"renderer/","title":"Rendering content: pl_frame, pl_renderer, and pl_queue","text":"<p>This example roughly builds off the previous entry, and as such will not cover the basics of how to create a window, initialize a <code>pl_gpu</code> and get pixels onto the screen.</p>"},{"location":"renderer/#renderer","title":"Renderer","text":"<p>The <code>pl_renderer</code> set of APIs represents the highest-level interface into libplacebo, and is what most users who simply want to display e.g. a video feed on-screen will want to be using.</p> <p>The basic initialization is straightforward, requiring no extra parameters:</p> <pre><code>pl_renderer renderer;\n\ninit()\n{\n    renderer = pl_renderer_create(pllog, gpu);\n    if (!renderer)\n        goto error;\n\n    // ...\n}\n\nuninit()\n{\n    pl_renderer_destroy(&amp;renderer);\n}\n</code></pre> <p>What makes the renderer powerful is the large number of <code>pl_render_params</code> it exposes. By default, libplacebo provides several presets to use:</p> <ul> <li>pl_render_fast_params: Disables everything except for defaults. This is   the fastest possible configuration.</li> <li>pl_render_default_params: Contains the recommended default parameters,   including some slightly higher quality scaling, as well as dithering.</li> <li>pl_render_high_quality_params: A preset of reasonable defaults for a   higher-end machine (i.e. anything with a discrete GPU). This enables most   of the basic functionality, including upscaling, downscaling, debanding   and better HDR tone mapping.</li> </ul> <p>Covering all of the possible options exposed by <code>pl_render_params</code> is out-of-scope of this example and would be better served by looking at the API documentation.</p>"},{"location":"renderer/#frames","title":"Frames","text":"<p><code>pl_frame</code> is the struct libplacebo uses to group textures and their metadata together into a coherent unit that can be rendered using the renderer. This is not currently a dynamically allocated or refcounted heap object, it is merely a struct that can live on the stack (or anywhere else). The actual data lives in corresponding <code>pl_tex</code> objects referenced in each of the frame's planes.</p> <pre><code>bool render_frame(const struct pl_frame *image,\n                  const struct pl_swapchain_frame *swframe)\n{\n    struct pl_frame target;\n    pl_frame_from_swapchain(&amp;target, swframe);\n\n    return pl_render_image(renderer, image, target,\n                           &amp;pl_render_default_params);\n}\n</code></pre> <p>Renderer state</p> <p>The <code>pl_renderer</code> is conceptually (almost) stateless. The only thing that is needed to get a different result is to change the render params, which can be varied freely on every call, if the user desires.</p> <p>The one case where this is not entirely true is when using frame mixing (see below), or when using HDR peak detection. In this case, the renderer can be explicitly reset using <code>pl_renderer_flush_cache</code>.</p> <p>To upload frames, the easiest methods are made available as dedicated helpers in <code>&lt;libplacebo/utils/upload.h&gt;</code>, and <code>&lt;libplacebo/utils/libav.h&gt;</code> (for AVFrames). In general, I recommend checking out the demo programs for a clearer illustration of how to use them in practice.</p>"},{"location":"renderer/#shader-cache","title":"Shader cache","text":"<p>The renderer internally generates, compiles and caches a potentially large number of shader programs, some of which can be complex. On some platforms (notably D3D11), these can be quite costly to recompile on every program launch.</p> <p>As such, the renderer offers a way to save/restore its internal shader cache from some external location (managed by the API user). The use of this API is highly recommended:</p> <pre><code>static uint8_t *load_saved_cache();\nstatic void store_saved_cache(uint8_t *cache, size_t bytes);\n\nvoid init()\n{\n    renderer = pl_renderer_create(pllog, gpu);\n    if (!renderer)\n        goto error;\n\n    uint8_t *cache = load_saved_cache();\n    if (cache) {\n        pl_renderer_load(renderer, cache);\n        free(cache);\n    }\n\n    // ...\n}\n\nvoid uninit()\n{\n    size_t cache_bytes = pl_renderer_save(renderer, NULL);\n    uint8_t *cache = malloc(cache_bytes);\n    if (cache) {\n        pl_renderer_save(renderer, cache);\n        store_saved_cache(cache, cache_bytes);\n        free(cache);\n    }\n\n    pl_renderer_destroy(&amp;renderer);\n}\n</code></pre> <p>Cache safety</p> <p>libplacebo performs only minimal validity checking on the shader cache, and in general, cannot possibly guard against malicious alteration of such files. Loading a cache from an untrusted source represents a remote code execution vector.</p>"},{"location":"renderer/#frame-mixing","title":"Frame mixing","text":"<p>One of the renderer's most powerful features is its ability to compensate for differences in framerates between the source and display by using frame mixing to blend adjacent frames together.</p> <p>Using this API requires presenting the renderer, at each vsync, with a <code>pl_frame_mix</code> struct, describing the current state of the vsync. In principle, such structs can be constructed by hand. To do this, all of the relevant frames (nearby the vsync timestamp) must be collected, and their relative distances to the vsync determined, by normalizing all PTS values such that the vsync represents time <code>0.0</code> (and a distance of <code>1.0</code> represents the nominal duration between adjacent frames). Note that timing vsyncs, and determining the correct vsync duration, are both left as problems for the user to solve.<sup>1</sup>. Here could be an example of a valid struct:</p> <pre><code>(struct pl_frame_mix) {\n    .num_frames = 6\n    .frames = (const struct pl_frame *[]) {\n        /* frame 0 */\n        /* frame 1 */\n        /* ... */\n        /* frame 5 */\n    },\n    .signatures = (uint64_t[]) {\n        0x0, 0x1, 0x2, 0x3, 0x4, 0x5 // (1)\n    },\n    .timestamps = (float[]) {\n        -2.4, -1.4, -0.4, 0.6, 1.6, 2.6, // (2)\n    },\n    .vsync_duration = 0.4, // 24 fps video on 60 fps display\n}\n</code></pre> <ol> <li> <p>These must be unique per frame, but always refer to the same frame. For     example, this could be based on the frame's PTS, the frame's numerical ID     (in order of decoding), or some sort of hash. The details don't matter,     only that this uniquely identifies specific frames.</p> </li> <li> <p>Typically, for CFR sources, frame timestamps will always be separated in     this list by a distance of 1.0. In this example, the vsync falls roughly     halfway (but not quite) in between two adjacent frames (with IDs 0x2 and     0x3).</p> </li> </ol> <p>Frame mixing radius</p> <p>In this example, the frame mixing radius (as determined by <code>pl_frame_mix_radius</code> is <code>3.0</code>, so we include all frames that fall within the timestamp interval of <code>[-3, 3)</code>. In general, you should consult this function to determine what frames need to be included in the <code>pl_frame_mix</code> - though including more frames than needed is not an error.</p>"},{"location":"renderer/#frame-queue","title":"Frame queue","text":"<p>Because this API is rather unwieldy and clumsy to use directly, libplacebo provides a helper abstraction known as <code>pl_queue</code> to assist in transforming some arbitrary source of frames (such as a video decoder) into nicely packed <code>pl_frame_mix</code> structs ready for consumption by the <code>pl_renderer</code>:</p> <pre><code>#include &lt;libplacebo/utils/frame_queue.h&gt;\n\npl_queue queue;\n\nvoid init()\n{\n    queue = pl_queue_create(gpu);\n}\n\nvoid uninit()\n{\n    pl_queue_destroy(&amp;queue);\n    // ...\n}\n</code></pre> <p>This queue can be interacted with through a number of mechanisms: either pushing frames (blocking or non-blocking), or by having the queue poll frames (via blocking or non-blocking callback) as-needed. For a full overview of the various methods of pushing and polling frames, check the API documentation.</p> <p>In this example, I will assume that we have a separate decoder thread pushing frames into the <code>pl_queue</code> in a blocking manner:</p> <pre><code>static void decoder_thread(void)\n{\n    void *frame;\n\n    while ((frame = /* decode new frame */)) {\n        pl_queue_push_block(queue, UINT64_MAX, &amp;(struct pl_source_frame) {\n            .pts        = /* frame pts */,\n            .duration   = /* frame duration */,\n            .map        = /* map callback */,\n            .unmap      = /* unmap callback */,\n            .frame_data = frame,\n        });\n    }\n\n    pl_queue_push(queue, NULL); // signal EOF\n}\n</code></pre> <p>Now, in our render loop, we want to call <code>pl_queue_update</code> with appropriate values to retrieve the correct frame mix for each vsync:</p> <pre><code>bool render_frame(const struct pl_swapchain_frame *swframe)\n{\n    struct pl_frame_mix mix;\n    enum pl_queue_status res;\n    res = pl_queue_update(queue, &amp;mix, pl_queue_params(\n        .pts            = /* time of next vsync */,\n        .radius         = pl_frame_mix_radius(&amp;render_params),\n        .vsync_duration = /* if known */,\n        .timeout        = UINT64_MAX, // (2)\n    ));\n\n    switch (res) {\n    case PL_QUEUE_OK:\n        break;\n    case PL_QUEUE_EOF:\n        /* no more frames */\n        return false;\n    case PL_QUEUE_ERR:\n        goto error;\n    // (1)\n    }\n\n\n    struct pl_frame target;\n    pl_frame_from_swapchain(&amp;target, swframe);\n\n    return pl_render_image_mix(renderer, &amp;mix, target,\n                               &amp;pl_render_default_params);\n}\n</code></pre> <ol> <li> <p>There is a fourth status, <code>PL_QUEUE_MORE</code>, which is returned only if the     resulting frame mix is incomplete (and the timeout was reached) -     basically this can only happen if the queue runs dry due to frames not     being supplied fast enough.</p> <p>In this example, since we are setting <code>timeout</code> to <code>UINT64_MAX</code>, we will never get this return value.</p> </li> <li> <p>Setting this makes <code>pl_queue_update</code> block indefinitely until sufficiently     many frames have been pushed into the <code>pl_queue</code> from our separate     decoding thread.</p> </li> </ol>"},{"location":"renderer/#deinterlacing","title":"Deinterlacing","text":"<p>The frame queue also vastly simplifies the process of performing motion-adaptive temporal deinterlacing, by automatically linking together adjacent fields/frames. To take advantage of this, all you need to do is set the appropriate field (<code>pl_source_frame.first_frame</code>), as well as enabling deinterlacing parameters.</p> <ol> <li> <p>However, this may change in the future, as the recent introduction of   the Vulkan display timing extension may result in display timing feedback   being added to the <code>pl_swapchain</code> API. That said, as of writing, this has   not yet happened.\u00a0\u21a9</p> </li> </ol>"}]}